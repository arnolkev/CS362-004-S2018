Result for running Dominion test suit:
randomtestadventurer.c:
playAdventurer() random test
Status: 0 pre 2 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 50 pre 52 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 114 pre 116 post
Test: FAILED
Status: 31 pre 33 post
Test: PASSED
Status: 205 pre 207 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 74 pre 76 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 68 pre 70 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 115 pre 117 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 40 pre 42 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 77 pre 79 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 13 pre 15 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 72 pre 74 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 37 pre 39 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 75 pre 77 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 76 pre 78 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 46 pre 48 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 82 pre 84 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 138 pre 140 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 154 pre 156 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 165 pre 167 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 123 pre 125 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 21 pre 23 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 44 pre 46 post
Test: PASSED
Status: 298 pre 300 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 71 pre 73 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 37 pre 39 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 42 pre 44 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 62 pre 64 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 113 pre 115 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 54 pre 56 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 41 pre 43 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 88 pre 90 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 110 pre 112 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 57 pre 59 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 34 pre 36 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 54 pre 56 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 20 pre 22 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 64 pre 66 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 223 pre 225 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 84 pre 86 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 20 pre 22 post
Test: PASSED
Status: 146 pre 148 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 139 pre 141 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 86 pre 88 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 88 pre 90 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 81 pre 83 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 86 pre 88 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 32 pre 34 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 123 pre 125 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 24 pre 26 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 19 pre 21 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 62 pre 64 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 60 pre 62 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 43 pre 45 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 49 pre 51 post
Test: FAILED
Status: 27 pre 29 post
Test: PASSED
Status: 188 pre 190 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 27 pre 29 post
Test: PASSED
Status: 196 pre 198 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 64 pre 66 post
Test: FAILED
Status: 18 pre 20 post
Test: PASSED
Status: 168 pre 170 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 117 pre 119 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 100 pre 102 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 130 pre 132 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 25 pre 27 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 38 pre 40 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 78 pre 80 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 25 pre 27 post
Test: PASSED
Status: 223 pre 225 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 43 pre 45 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 37 pre 39 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 39 pre 41 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 21 pre 23 post
Test: PASSED
Status: 140 pre 142 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 165 pre 167 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 104 pre 106 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 28 pre 30 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 102 pre 104 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 84 pre 86 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 115 pre 117 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 49 pre 51 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 16 pre 18 post
Test: PASSED
Status: 211 pre 213 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 52 pre 54 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 24 pre 26 post
Test: PASSED
Status: 196 pre 198 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 80 pre 82 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 21 pre 23 post
Test: PASSED
Status: 158 pre 160 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 50 pre 52 post
Test: PASSED
Status: 421 pre 423 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 42 pre 44 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 33 pre 35 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 26 pre 28 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 18 pre 20 post
Test: PASSED
Status: 153 pre 155 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 12 pre 14 post
Test: PASSED
Status: 111 pre 113 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 48 pre 50 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 13 pre 15 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 73 pre 75 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 54 pre 56 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 46 pre 48 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 92 pre 94 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 19 pre 21 post
Test: FAILED
Status: 22 pre 24 post
Test: PASSED
Status: 169 pre 171 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 46 pre 48 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 41 pre 43 post
Test: FAILED
Status: 31 pre 33 post
Test: PASSED
Status: 256 pre 258 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 33 pre 35 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 28 pre 30 post
Test: PASSED
Status: 216 pre 218 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 37 pre 39 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 12 pre 14 post
Test: PASSED
Status: 96 pre 98 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 28 pre 30 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 24 pre 26 post
Test: FAILED
Status: 12 pre 14 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 22 pre 24 post
Test: PASSED
Status: 252 pre 254 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 97 pre 99 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 142 pre 144 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 96 pre 98 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 35 pre 37 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 116 pre 118 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 13 pre 15 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 25 pre 27 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 189 pre 191 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 147 pre 149 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 36 pre 38 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 72 pre 74 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 134 pre 136 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 78 pre 80 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 34 pre 36 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 135 pre 137 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 20 pre 22 post
Test: PASSED
Status: 132 pre 134 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 121 pre 123 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 112 pre 114 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 72 pre 74 post
Test: FAILED
Status: 35 pre 37 post
Test: PASSED
Status: 360 pre 362 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 25 pre 27 post
Test: PASSED
Status: 201 pre 203 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 32 pre 34 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 159 pre 161 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 93 pre 95 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 74 pre 76 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 57 pre 59 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 72 pre 74 post
Test: FAILED
Status: 22 pre 24 post
Test: PASSED
Status: 200 pre 202 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 83 pre 85 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 103 pre 105 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 39 pre 41 post
Test: PASSED
Status: 333 pre 335 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 50 pre 52 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 82 pre 84 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 26 pre 28 post
Test: PASSED
Status: 264 pre 266 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 88 pre 90 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 53 pre 55 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 125 pre 127 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 33 pre 35 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 17 pre 19 post
Test: PASSED
Status: 130 pre 132 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 53 pre 55 post
Test: FAILED
Status: 42 pre 44 post
Test: PASSED
Status: 282 pre 284 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 105 pre 107 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 34 pre 36 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 68 pre 70 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 106 pre 108 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 78 pre 80 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 42 pre 44 post
Test: PASSED
Status: 318 pre 320 post
Test: FAILED
Status: 16 pre 18 post
Test: PASSED
Status: 103 pre 105 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 58 pre 60 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 178 pre 180 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 80 pre 82 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 59 pre 61 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 109 pre 111 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 65 pre 67 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 35 pre 37 post
Test: PASSED
Status: 287 pre 289 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 13 pre 15 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 83 pre 85 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 38 pre 40 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 131 pre 133 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 85 pre 87 post
Test: FAILED
Status: 12 pre 14 post
Test: PASSED
Status: 133 pre 135 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 64 pre 66 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 20 pre 22 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 42 pre 44 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 53 pre 55 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 58 pre 60 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 72 pre 74 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 82 pre 84 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 84 pre 86 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 31 pre 33 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 41 pre 43 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 35 pre 37 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 137 pre 139 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 21 pre 23 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 91 pre 93 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 102 pre 104 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 53 pre 55 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 10 pre 12 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 38 pre 40 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 86 pre 88 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 26 pre 28 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 27 pre 29 post
Test: PASSED
Status: 258 pre 260 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 81 pre 83 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 73 pre 75 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 41 pre 43 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 7 pre 9 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 32 pre 34 post
Test: PASSED
Status: 257 pre 259 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 54 pre 56 post
Test: FAILED
Status: 25 pre 27 post
Test: PASSED
Status: 180 pre 182 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 121 pre 123 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 155 pre 157 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 24 pre 26 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 97 pre 99 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 25 pre 27 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 32 pre 34 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 26 pre 28 post
Test: FAILED
Status: 19 pre 21 post
Test: PASSED
Status: 131 pre 133 post
Test: FAILED
Status: 16 pre 18 post
Test: PASSED
Status: 176 pre 178 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 42 pre 44 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 40 pre 42 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 101 pre 103 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 105 pre 107 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 24 pre 26 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 49 pre 51 post
Test: PASSED
Status: 458 pre 460 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 3 pre 5 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 39 pre 41 post
Test: PASSED
Status: 304 pre 306 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 2 pre 4 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 27 pre 29 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 82 pre 84 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 38 pre 40 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 39 pre 41 post
Test: FAILED
Status: 24 pre 26 post
Test: PASSED
Status: 173 pre 175 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 30 pre 32 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 58 pre 60 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 139 pre 141 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 45 pre 47 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 87 pre 89 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 60 pre 62 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 61 pre 63 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 33 pre 35 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 31 pre 33 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 78 pre 80 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 17 pre 19 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 53 pre 55 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 18 pre 20 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 44 pre 46 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 19 pre 21 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 71 pre 73 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 31 pre 33 post
Test: PASSED
Status: 202 pre 204 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 126 pre 128 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 33 pre 35 post
Test: FAILED
Status: 17 pre 19 post
Test: PASSED
Status: 119 pre 121 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 21 pre 23 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 64 pre 66 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 5 pre 7 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 25 pre 27 post
Test: PASSED
Status: 240 pre 242 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 95 pre 97 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 87 pre 89 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 7 pre 9 post
Test: PASSED
Status: 55 pre 57 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 27 pre 29 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 32 pre 34 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 54 pre 56 post
Test: FAILED
Status: 13 pre 15 post
Test: PASSED
Status: 127 pre 129 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 6 pre 8 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 34 pre 36 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 4 pre 6 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 62 pre 64 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 16 pre 18 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 26 pre 28 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 107 pre 109 post
Test: FAILED
Status: 14 pre 16 post
Test: PASSED
Status: 109 pre 111 post
Test: FAILED
Status: 30 pre 32 post
Test: PASSED
Status: 306 pre 308 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 110 pre 112 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 38 pre 40 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 29 pre 31 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 220 pre 222 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 98 pre 100 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 8 pre 10 post
Test: PASSED
Status: 65 pre 67 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 46 pre 48 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 26 pre 28 post
Test: FAILED
Status: 9 pre 11 post
Test: PASSED
Status: 48 pre 50 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 14 pre 16 post
Test: FAILED
Status: 33 pre 35 post
Test: PASSED
Status: 279 pre 281 post
Test: FAILED
Status: 11 pre 13 post
Test: PASSED
Status: 90 pre 92 post
Test: FAILED
Status: 17 pre 19 post
Test: PASSED
Status: 196 pre 198 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 2 pre 4 post
Test: PASSED
Status: 8 pre 10 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 56 pre 58 post
Test: FAILED
Status: 17 pre 19 post
Test: PASSED
Status: 107 pre 109 post
Test: FAILED
Status: 10 pre 12 post
Test: PASSED
Status: 43 pre 45 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 23 pre 25 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 11 pre 13 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 22 pre 24 post
Test: FAILED
Status: 3 pre 5 post
Test: PASSED
Status: 19 pre 21 post
Test: FAILED
Status: 16 pre 18 post
Test: PASSED
Status: 66 pre 68 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 12 pre 14 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 1 pre 3 post
Test: FAILED
Status: 15 pre 17 post
Test: PASSED
Status: 135 pre 137 post
Test: FAILED
Status: 23 pre 25 post
Test: PASSED
Status: 196 pre 198 post
Test: FAILED
Status: 12 pre 14 post
Test: PASSED
Status: 77 pre 79 post
Test: FAILED
Status: 5 pre 7 post
Test: PASSED
Status: 62 pre 64 post
Test: FAILED
Status: 0 pre 2 post
Test: PASSED
Status: 13 pre 15 post
Test: FAILED
Status: 4 pre 6 post
Test: PASSED
Status: 15 pre 17 post
Test: FAILED
Status: 6 pre 8 post
Test: PASSED
Status: 31 pre 33 post
Test: FAILED
Status: 1 pre 3 post
Test: PASSED
Status: 9 pre 11 post
Test: FAILED
Status: 500 failures of the playAdventurer
File 'randomtestadventurer.c'
Lines executed:100.00% of 56
Creating 'randomtestadventurer.c.gcov'

File 'dominion.c'
Lines executed:24.65% of 564
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
  1078043:    8:int compare(const void* a, const void* b) {
  1078043:    9:  if (*(int*)a > *(int*)b)
   533092:   10:    return 1;
   544951:   11:  if (*(int*)a < *(int*)b)
   240075:   12:    return -1;
   304876:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
    #####:   18:      drawCard(currentPlayer, state);
        -:   19:			
        -:   20:      //+2 Actions
    #####:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
    #####:   24:      discardCard(handPos, currentPlayer, state, 0);
    #####:   25:}
        -:   26:
    #####:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
    #####:   29:    for (i = 1; i < 3; i++)
        -:   30:	{
    #####:   31:	  drawCard(currentPlayer, state);
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
    #####:   36:      discardCard(handPos, currentPlayer, state, 0);
        -:   37: 
        -:   38:
    #####:   39:}
      500:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
      500:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
      500:   44:int z = 0;
    11930:   45:while(drawntreasure<2){
    10930:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
       70:   47:	  shuffle(currentPlayer, state);
        -:   48:	}
    10930:   49:	drawCard(currentPlayer, state);
        -:   50:
    10930:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    10930:   52:	if (cardDrawn == copper || cardDrawn == silver)
     1000:   53:	  drawntreasure++;
        -:   54:	else{
     9930:   55:	  temphand[z]=cardDrawn;
     9930:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     9930:   57:	  z++;
        -:   58:	}
        -:   59:      }
    10930:   60:      while(z-1>=0){
     9930:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     9930:   62:	z=z-1;
      500:   63:      }}
        -:   64:
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
    #####:   91:		isGameOver(state);
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
    #####:  108:	    isGameOver(state);
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
    #####:  121:	  drawCard(currentPlayer, state);
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
    #####:  139:}
        -:  140:
        -:  141:
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
      500:  171:  PutSeed((long)randomSeed);
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:  175:    {
      254:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      246:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2706:  183:  for (i = 0; i < 10; i++)
        -:  184:    {
    27060:  185:      for (j = 0; j < 10; j++)
        -:  186:        {
    24600:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      246:  199:  if (numPlayers == 2)
        -:  200:    {
      110:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      136:  203:  else if (numPlayers == 3)
        -:  204:    {
      136:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      246:  213:  if (numPlayers == 2)
        -:  214:    {
      110:  215:      state->supplyCount[estate] = 8;
      110:  216:      state->supplyCount[duchy] = 8;
      110:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      136:  221:      state->supplyCount[estate] = 12;
      136:  222:      state->supplyCount[duchy] = 12;
      136:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      246:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      246:  228:  state->supplyCount[silver] = 40;
      246:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5166:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  233:    {
    40590:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  235:	{
    38130:  236:	  if (kingdomCards[j] == i)
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2460:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  240:		{
      492:  241:		  if (numPlayers == 2){ 
      110:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      136:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2214:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2460:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    35670:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      874:  264:  for (i = 0; i < numPlayers; i++)
        -:  265:    {
      628:  266:      state->deckCount[i] = 0;
     2512:  267:      for (j = 0; j < 3; j++)
        -:  268:	{
     1884:  269:	  state->deck[i][j] = estate;
     1884:  270:	  state->deckCount[i]++;
        -:  271:	}
     5024:  272:      for (j = 3; j < 10; j++)
        -:  273:	{
     4396:  274:	  state->deck[i][j] = copper;
     4396:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      874:  280:  for (i = 0; i < numPlayers; i++)
        -:  281:    {
      628:  282:      if ( shuffle(i, state) < 0 )
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      874:  289:  for (i = 0; i < numPlayers; i++)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      628:  292:      state->handCount[i] = 0;
      628:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6888:  302:  for (i = 0; i <= treasure_map; i++)
        -:  303:    {
     6642:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      246:  308:  state->outpostPlayed = 0;
      246:  309:  state->phase = 0;
      246:  310:  state->numActions = 1;
      246:  311:  state->numBuys = 1;
      246:  312:  state->playedCardCount = 0;
      246:  313:  state->whoseTurn = 0;
      246:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1476:  318:  for (it = 0; it < 5; it++){
     1230:  319:    drawCard(state->whoseTurn, state);
        -:  320:  }
        -:  321:
      246:  322:  updateCoins(state->whoseTurn, state, 0);
        -:  323:
      246:  324:  return 0;
        -:  325:}
        -:  326:
     1268:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1268:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1268:  335:  if (state->deckCount[player] < 1)
       71:  336:    return -1;
     1197:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   160860:  340:  while (state->deckCount[player] > 0) {
   158466:  341:    card = floor(Random() * state->deckCount[player]);
   158466:  342:    newDeck[newDeckPos] = state->deck[player][card];
   158466:  343:    newDeckPos++;
 13304078:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
 13145612:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   158466:  347:    state->deckCount[player]--;
        -:  348:  }
   159663:  349:  for (i = 0; i < newDeckPos; i++) {
   158466:  350:    state->deck[player][i] = newDeck[i];
   158466:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1197:  354:  return 0;
        -:  355:}
        -:  356:
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
        -:  439:}
        -:  440:
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
    12160:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
    12160:  654:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    24404:  659:    for (i = 0; i < state->discardCount[player];i++){
    24334:  660:      state->deck[player][i] = state->discard[player][i];
    24334:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       70:  664:    state->deckCount[player] = state->discardCount[player];
       70:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       70:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       70:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       70:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       70:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       70:  685:    if (deckCounter == 0)
    #####:  686:      return -1;
        -:  687:
       70:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       70:  689:    state->deckCount[player]--;
       70:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
    12090:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
    12090:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
    12090:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    12090:  702:    state->deckCount[player]--;
    12090:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
    12160:  706:  return 0;
        -:  707:}
        -:  708:
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
        1:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
        -:  794:    {
        -:  795:    case adventurer:
      500:  796:      playAdventurer(currentPlayer, state, handPos);
      500:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
    #####:  836:	if (supplyCount(choice1, state) <= 0){
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
    #####:  845:	  printf("That card is too expensive!\n");
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
    #####:  943:      playSmithy(currentPlayer, state, handPos);
    #####:  944:      return 0;
        -:  945:
        -:  946:    case village:
    #####:  947:      playVillage(currentPlayer, state, handPos);
    #####:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1070:	  drawCard(currentPlayer, state);
    #####: 1071:	  drawCard(currentPlayer, state);
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
    #####: 1216:	if (i != currentPlayer){
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
    #####: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
    #####: 1262:  if (trashFlag < 1)
        -: 1263:    {
        -: 1264:      //add card to played pile
    #####: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
    #####: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
    #####: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
    #####: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
    #####: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
    #####: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
    #####: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
    #####: 1293:  return 0;
        -: 1294:}
        -: 1295:
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
      246: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      246: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1476: 1341:  for (i = 0; i < state->handCount[player]; i++)
        -: 1342:    {
     1230: 1343:      if (state->hand[player][i] == copper)
        -: 1344:	{
      850: 1345:	  state->coins += 1;
        -: 1346:	}
      380: 1347:      else if (state->hand[player][i] == silver)
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      380: 1351:      else if (state->hand[player][i] == gold)
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      246: 1358:  state->coins += bonus;
        -: 1359:
      246: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
File 'randomtestadventurer.c'
Lines executed:100.00% of 56
Branches executed:100.00% of 32
Taken at least once:100.00% of 32
Calls executed:100.00% of 22
Creating 'randomtestadventurer.c.gcov'

File 'dominion.c'
Lines executed:24.65% of 564
Branches executed:25.30% of 415
Taken at least once:18.55% of 415
Calls executed:12.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1078043 returned 100% blocks executed 100%
  1078043:    8:int compare(const void* a, const void* b) {
  1078043:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 533092 (fallthrough)
branch  1 taken 544951
   533092:   10:    return 1;
   544951:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 240075 (fallthrough)
branch  1 taken 304876
   240075:   12:    return -1;
   304876:   13:  return 0;
        -:   14:}
        -:   15:
function playVillage called 0 returned 0% blocks executed 0%
    #####:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
    #####:   18:      drawCard(currentPlayer, state);
call    0 never executed
        -:   19:			
        -:   20:      //+2 Actions
    #####:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
    #####:   24:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:   25:}
        -:   26:
function playSmithy called 0 returned 0% blocks executed 0%
    #####:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
    #####:   29:    for (i = 1; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:   30:	{
    #####:   31:	  drawCard(currentPlayer, state);
call    0 never executed
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
    #####:   36:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:   37: 
        -:   38:
    #####:   39:}
function playAdventurer called 500 returned 100% blocks executed 100%
      500:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
      500:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
      500:   44:int z = 0;
    11930:   45:while(drawntreasure<2){
branch  0 taken 10930
branch  1 taken 500 (fallthrough)
    10930:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 taken 70 (fallthrough)
branch  1 taken 10860
       70:   47:	  shuffle(currentPlayer, state);
call    0 returned 70
        -:   48:	}
    10930:   49:	drawCard(currentPlayer, state);
call    0 returned 10930
        -:   50:
    10930:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    10930:   52:	if (cardDrawn == copper || cardDrawn == silver)
branch  0 taken 10338 (fallthrough)
branch  1 taken 592
branch  2 taken 408 (fallthrough)
branch  3 taken 9930
     1000:   53:	  drawntreasure++;
        -:   54:	else{
     9930:   55:	  temphand[z]=cardDrawn;
     9930:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
     9930:   57:	  z++;
        -:   58:	}
        -:   59:      }
    10930:   60:      while(z-1>=0){
branch  0 taken 9930
branch  1 taken 500 (fallthrough)
     9930:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
     9930:   62:	z=z-1;
      500:   63:      }}
        -:   64:
function playBaron called 0 returned 0% blocks executed 0%
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   91:		isGameOver(state);
call    0 never executed
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:	    isGameOver(state);
call    0 never executed
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
function playSteward called 0 returned 0% blocks executed 0%
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  121:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####:  139:}
        -:  140:
        -:  141:
function newGame called 0 returned 0% blocks executed 0%
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
function initializeGame called 500 returned 100% blocks executed 95%
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
call    0 returned 500
      500:  171:  PutSeed((long)randomSeed);
call    0 returned 500
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 500 (fallthrough)
branch  1 taken 0
branch  2 taken 254 (fallthrough)
branch  3 taken 246
        -:  175:    {
      254:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      246:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2706:  183:  for (i = 0; i < 10; i++)
branch  0 taken 2460
branch  1 taken 246 (fallthrough)
        -:  184:    {
    27060:  185:      for (j = 0; j < 10; j++)
branch  0 taken 24600
branch  1 taken 2460 (fallthrough)
        -:  186:        {
    24600:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 22140 (fallthrough)
branch  1 taken 2460
branch  2 taken 0 (fallthrough)
branch  3 taken 22140
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      246:  199:  if (numPlayers == 2)
branch  0 taken 110 (fallthrough)
branch  1 taken 136
        -:  200:    {
      110:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      136:  203:  else if (numPlayers == 3)
branch  0 taken 136 (fallthrough)
branch  1 taken 0
        -:  204:    {
      136:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      246:  213:  if (numPlayers == 2)
branch  0 taken 110 (fallthrough)
branch  1 taken 136
        -:  214:    {
      110:  215:      state->supplyCount[estate] = 8;
      110:  216:      state->supplyCount[duchy] = 8;
      110:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      136:  221:      state->supplyCount[estate] = 12;
      136:  222:      state->supplyCount[duchy] = 12;
      136:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      246:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      246:  228:  state->supplyCount[silver] = 40;
      246:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5166:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 4920
branch  1 taken 246 (fallthrough)
        -:  233:    {
    40590:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 38130
branch  1 taken 2460 (fallthrough)
        -:  235:	{
    38130:  236:	  if (kingdomCards[j] == i)
branch  0 taken 2460 (fallthrough)
branch  1 taken 35670
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2460:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 2214 (fallthrough)
branch  1 taken 246
branch  2 taken 0 (fallthrough)
branch  3 taken 2214
        -:  240:		{
      492:  241:		  if (numPlayers == 2){ 
branch  0 taken 110 (fallthrough)
branch  1 taken 136
      110:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      136:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2214:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2460:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    35670:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      874:  264:  for (i = 0; i < numPlayers; i++)
branch  0 taken 628
branch  1 taken 246 (fallthrough)
        -:  265:    {
      628:  266:      state->deckCount[i] = 0;
     2512:  267:      for (j = 0; j < 3; j++)
branch  0 taken 1884
branch  1 taken 628 (fallthrough)
        -:  268:	{
     1884:  269:	  state->deck[i][j] = estate;
     1884:  270:	  state->deckCount[i]++;
        -:  271:	}
     5024:  272:      for (j = 3; j < 10; j++)
branch  0 taken 4396
branch  1 taken 628 (fallthrough)
        -:  273:	{
     4396:  274:	  state->deck[i][j] = copper;
     4396:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      874:  280:  for (i = 0; i < numPlayers; i++)
branch  0 taken 628
branch  1 taken 246 (fallthrough)
        -:  281:    {
      628:  282:      if ( shuffle(i, state) < 0 )
call    0 returned 628
branch  1 taken 0 (fallthrough)
branch  2 taken 628
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      874:  289:  for (i = 0; i < numPlayers; i++)
branch  0 taken 628
branch  1 taken 246 (fallthrough)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      628:  292:      state->handCount[i] = 0;
      628:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6888:  302:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 6642
branch  1 taken 246 (fallthrough)
        -:  303:    {
     6642:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      246:  308:  state->outpostPlayed = 0;
      246:  309:  state->phase = 0;
      246:  310:  state->numActions = 1;
      246:  311:  state->numBuys = 1;
      246:  312:  state->playedCardCount = 0;
      246:  313:  state->whoseTurn = 0;
      246:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1476:  318:  for (it = 0; it < 5; it++){
branch  0 taken 1230
branch  1 taken 246 (fallthrough)
     1230:  319:    drawCard(state->whoseTurn, state);
call    0 returned 1230
        -:  320:  }
        -:  321:
      246:  322:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 246
        -:  323:
      246:  324:  return 0;
        -:  325:}
        -:  326:
function shuffle called 1268 returned 100% blocks executed 100%
     1268:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1268:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1268:  335:  if (state->deckCount[player] < 1)
branch  0 taken 71 (fallthrough)
branch  1 taken 1197
       71:  336:    return -1;
     1197:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 1197
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   160860:  340:  while (state->deckCount[player] > 0) {
branch  0 taken 158466
branch  1 taken 1197 (fallthrough)
   158466:  341:    card = floor(Random() * state->deckCount[player]);
call    0 returned 158466
   158466:  342:    newDeck[newDeckPos] = state->deck[player][card];
   158466:  343:    newDeckPos++;
 13304078:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 13145612
branch  1 taken 158466 (fallthrough)
 13145612:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   158466:  347:    state->deckCount[player]--;
        -:  348:  }
   159663:  349:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 158466
branch  1 taken 1197 (fallthrough)
   158466:  350:    state->deck[player][i] = newDeck[i];
   158466:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1197:  354:  return 0;
        -:  355:}
        -:  356:
function playCard called 0 returned 0% blocks executed 0%
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
call    0 never executed
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  439:}
        -:  440:
function handCard called 0 returned 0% blocks executed 0%
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
function whoseTurn called 500 returned 100% blocks executed 100%
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
function drawCard called 12160 returned 100% blocks executed 92%
    12160:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
    12160:  654:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 70 (fallthrough)
branch  1 taken 12090
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    24404:  659:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 24334
branch  1 taken 70 (fallthrough)
    24334:  660:      state->deck[player][i] = state->discard[player][i];
    24334:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       70:  664:    state->deckCount[player] = state->discardCount[player];
       70:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       70:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 70
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       70:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       70:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       70:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       70:  685:    if (deckCounter == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 70
    #####:  686:      return -1;
        -:  687:
       70:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       70:  689:    state->deckCount[player]--;
       70:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
    12090:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
    12090:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
    12090:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    12090:  702:    state->deckCount[player]--;
    12090:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
    12160:  706:  return 0;
        -:  707:}
        -:  708:
function getCost called 0 returned 0% blocks executed 0%
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
function cardEffect called 500 returned 100% blocks executed 4%
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
call    0 returned 500
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 1 (fallthrough)
branch  1 taken 499
        1:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
branch  0 taken 500
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
        -:  794:    {
        -:  795:    case adventurer:
      500:  796:      playAdventurer(currentPlayer, state, handPos);
call    0 returned 500
      500:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
call    0 never executed
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  836:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
    #####:  943:      playSmithy(currentPlayer, state, handPos);
call    0 never executed
    #####:  944:      return 0;
        -:  945:
        -:  946:    case village:
    #####:  947:      playVillage(currentPlayer, state, handPos);
call    0 never executed
    #####:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
call    0 never executed
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
call    0 never executed
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
call    0 never executed
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
call    0 never executed
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1070:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1071:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1216:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
    #####: 1262:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1263:    {
        -: 1264:      //add card to played pile
    #####: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
    #####: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
    #####: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
    #####: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
    #####: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
    #####: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
    #####: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
    #####: 1293:  return 0;
        -: 1294:}
        -: 1295:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
function updateCoins called 246 returned 100% blocks executed 82%
      246: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      246: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1476: 1341:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 1230
branch  1 taken 246 (fallthrough)
        -: 1342:    {
     1230: 1343:      if (state->hand[player][i] == copper)
branch  0 taken 850 (fallthrough)
branch  1 taken 380
        -: 1344:	{
      850: 1345:	  state->coins += 1;
        -: 1346:	}
      380: 1347:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 380
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      380: 1351:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 380
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      246: 1358:  state->coins += bonus;
        -: 1359:
      246: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
randomtestcard1.c:
playSmithy() random test
Status: 22 pre 23 post
Test: FAILED
Status: 246 pre 141 103 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 493 pre 484 7 post
Test: FAILED
Status: 16 pre 17 post
Test: FAILED
Status: 484 pre 469 13 post
Test: FAILED
Status: 52 pre 53 post
Test: FAILED
Status: 442 pre 42 398 post
Test: FAILED
Status: 116 pre 117 post
Test: FAILED
Status: 297 pre 57 238 post
Test: FAILED
Status: 18 pre 19 post
Test: FAILED
Status: 463 pre 428 33 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 477 pre 454 21 post
Test: FAILED
Status: 230 pre 231 post
Test: FAILED
Status: 85 pre 21 62 post
Test: FAILED
Status: 72 pre 73 post
Test: FAILED
Status: 158 pre 139 17 post
Test: FAILED
Status: 128 pre 129 post
Test: FAILED
Status: 354 pre 255 97 post
Test: FAILED
Status: 21 pre 22 post
Test: FAILED
Status: 416 pre 67 347 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 440 pre 405 33 post
Test: FAILED
Status: 17 pre 18 post
Test: FAILED
Status: 417 pre 318 97 post
Test: FAILED
Status: 61 pre 62 post
Test: FAILED
Status: 380 pre 378 0 post
Test: FAILED
Status: 89 pre 90 post
Test: FAILED
Status: 327 pre 150 175 post
Test: FAILED
Status: 85 pre 86 post
Test: FAILED
Status: 332 pre 114 216 post
Test: FAILED
Status: 136 pre 137 post
Test: FAILED
Status: 344 pre 185 157 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 366 pre 108 256 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 438 pre 84 352 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 497 pre 489 6 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 472 pre 75 395 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 494 pre 492 0 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 473 pre 470 1 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 434 pre 61 371 post
Test: FAILED
Status: 53 pre 54 post
Test: FAILED
Status: 399 pre 397 0 post
Test: FAILED
Status: 88 pre 89 post
Test: FAILED
Status: 404 pre 351 51 post
Test: FAILED
Status: 109 pre 110 post
Test: FAILED
Status: 365 pre 321 42 post
Test: FAILED
Status: 28 pre 29 post
Test: FAILED
Status: 288 pre 286 0 post
Test: FAILED
Status: 63 pre 64 post
Test: FAILED
Status: 371 pre 273 96 post
Test: FAILED
Status: 51 pre 52 post
Test: FAILED
Status: 447 pre 385 60 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 471 pre 464 5 post
Test: FAILED
Status: 107 pre 108 post
Test: FAILED
Status: 362 pre 102 258 post
Test: FAILED
Status: 90 pre 91 post
Test: FAILED
Status: 357 pre 355 0 post
Test: FAILED
Status: 114 pre 115 post
Test: FAILED
Status: 359 pre 176 181 post
Test: FAILED
Status: 31 pre 32 post
Test: FAILED
Status: 300 pre 214 84 post
Test: FAILED
Status: 40 pre 41 post
Test: FAILED
Status: 399 pre 340 57 post
Test: FAILED
Status: 38 pre 39 post
Test: FAILED
Status: 52 pre 50 0 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 482 pre 263 217 post
Test: FAILED
Status: 92 pre 93 post
Test: FAILED
Status: 408 pre 406 0 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 459 pre 414 43 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 337 pre 101 234 post
Test: FAILED
Status: 142 pre 143 post
Test: FAILED
Status: 223 pre 163 58 post
Test: FAILED
Status: 183 pre 184 post
Test: FAILED
Status: 215 pre 182 31 post
Test: FAILED
Status: 34 pre 35 post
Test: FAILED
Status: 453 pre 430 21 post
Test: FAILED
Status: 244 pre 245 post
Test: FAILED
Status: 143 pre 17 124 post
Test: FAILED
Status: 19 pre 20 post
Test: FAILED
Status: 446 pre 443 1 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 477 pre 364 111 post
Test: FAILED
Status: 236 pre 237 post
Test: FAILED
Status: 62 pre 11 49 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 460 pre 446 12 post
Test: FAILED
Status: 98 pre 99 post
Test: FAILED
Status: 388 pre 73 313 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 443 pre 415 26 post
Test: FAILED
Status: 94 pre 95 post
Test: FAILED
Status: 314 pre 68 244 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 485 pre 463 20 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 473 pre 466 5 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 378 pre 242 134 post
Test: FAILED
Status: 53 pre 54 post
Test: FAILED
Status: 412 pre 149 261 post
Test: FAILED
Status: 155 pre 156 post
Test: FAILED
Status: 308 pre 128 178 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 368 pre 71 295 post
Test: FAILED
Status: 31 pre 32 post
Test: FAILED
Status: 451 pre 449 0 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 429 pre 126 301 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 432 pre 424 6 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 464 pre 331 131 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 496 pre 372 122 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 236 pre 97 137 post
Test: FAILED
Status: 87 pre 88 post
Test: FAILED
Status: 391 pre 62 327 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 498 pre 491 5 post
Test: FAILED
Status: 385 pre 386 post
Test: FAILED
Status: 99 pre 11 86 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 481 pre 438 41 post
Test: FAILED
Status: 120 pre 121 post
Test: FAILED
Status: 136 pre 101 33 post
Test: FAILED
Status: 170 pre 171 post
Test: FAILED
Status: 322 pre 320 0 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 278 pre 203 73 post
Test: FAILED
Status: 182 pre 183 post
Test: FAILED
Status: 271 pre 162 107 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 474 pre 415 57 post
Test: FAILED
Status: 32 pre 33 post
Test: FAILED
Status: 300 pre 294 4 post
Test: FAILED
Status: 224 pre 225 post
Test: FAILED
Status: 89 pre 45 42 post
Test: FAILED
Status: 92 pre 93 post
Test: FAILED
Status: 320 pre 267 51 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 496 pre 221 273 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 470 pre 468 0 post
Test: FAILED
Status: 132 pre 133 post
Test: FAILED
Status: 258 pre 157 99 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 481 pre 368 111 post
Test: FAILED
Status: 133 pre 134 post
Test: FAILED
Status: 98 pre 81 15 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 497 pre 495 0 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 447 pre 445 0 post
Test: FAILED
Status: 299 pre 300 post
Test: FAILED
Status: 123 pre 111 10 post
Test: FAILED
Status: 23 pre 24 post
Test: FAILED
Status: 390 pre 295 93 post
Test: FAILED
Status: 120 pre 121 post
Test: FAILED
Status: 212 pre 95 115 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 293 pre 253 38 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 489 pre 487 0 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 494 pre 492 0 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 487 pre 311 174 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 472 pre 436 34 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 176 pre 165 9 post
Test: FAILED
Status: 136 pre 137 post
Test: FAILED
Status: 358 pre 353 3 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 495 pre 487 6 post
Test: FAILED
Status: 21 pre 22 post
Test: FAILED
Status: 467 pre 438 27 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 411 pre 292 117 post
Test: FAILED
Status: 16 pre 17 post
Test: FAILED
Status: 386 pre 314 70 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 491 pre 479 10 post
Test: FAILED
Status: 32 pre 33 post
Test: FAILED
Status: 461 pre 386 73 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 333 pre 235 96 post
Test: FAILED
Status: 132 pre 133 post
Test: FAILED
Status: 143 pre 8 133 post
Test: FAILED
Status: 119 pre 120 post
Test: FAILED
Status: 373 pre 330 41 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 462 pre 255 205 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 489 pre 412 75 post
Test: FAILED
Status: 217 pre 218 post
Test: FAILED
Status: 255 pre 166 87 post
Test: FAILED
Status: 65 pre 66 post
Test: FAILED
Status: 404 pre 27 375 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 347 pre 72 273 post
Test: FAILED
Status: 16 pre 17 post
Test: FAILED
Status: 474 pre 173 299 post
Test: FAILED
Status: 33 pre 34 post
Test: FAILED
Status: 461 pre 430 29 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 413 pre 396 15 post
Test: FAILED
Status: 47 pre 48 post
Test: FAILED
Status: 404 pre 340 62 post
Test: FAILED
Status: 31 pre 32 post
Test: FAILED
Status: 464 pre 450 12 post
Test: FAILED
Status: 54 pre 55 post
Test: FAILED
Status: 440 pre 257 181 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 441 pre 199 240 post
Test: FAILED
Status: 48 pre 49 post
Test: FAILED
Status: 363 pre 137 224 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 259 pre 84 173 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 457 pre 455 0 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 313 pre 80 231 post
Test: FAILED
Status: 98 pre 99 post
Test: FAILED
Status: 367 pre 220 145 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 415 pre 413 0 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 455 pre 184 269 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 494 pre 483 9 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 486 pre 477 7 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 381 pre 343 36 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 494 pre 463 29 post
Test: FAILED
Status: 131 pre 132 post
Test: FAILED
Status: 269 pre 92 175 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 424 pre 414 8 post
Test: FAILED
Status: 16 pre 17 post
Test: FAILED
Status: 476 pre 329 145 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 447 pre 439 6 post
Test: FAILED
Status: 99 pre 100 post
Test: FAILED
Status: 401 pre 168 231 post
Test: FAILED
Status: 23 pre 24 post
Test: FAILED
Status: 400 pre 257 141 post
Test: FAILED
Status: 261 pre 262 post
Test: FAILED
Status: 214 pre 165 47 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 440 pre 423 15 post
Test: FAILED
Status: 82 pre 83 post
Test: FAILED
Status: 373 pre 49 322 post
Test: FAILED
Status: 99 pre 100 post
Test: FAILED
Status: 279 pre 81 196 post
Test: FAILED
Status: 144 pre 145 post
Test: FAILED
Status: 348 pre 230 116 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 456 pre 227 227 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 417 pre 415 0 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 494 pre 424 68 post
Test: FAILED
Status: 65 pre 66 post
Test: FAILED
Status: 283 pre 70 211 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 233 pre 152 79 post
Test: FAILED
Status: 112 pre 113 post
Test: FAILED
Status: 387 pre 274 111 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 458 pre 429 27 post
Test: FAILED
Status: 24 pre 25 post
Test: FAILED
Status: 450 pre 439 9 post
Test: FAILED
Status: 83 pre 84 post
Test: FAILED
Status: 384 pre 92 290 post
Test: FAILED
Status: 325 pre 326 post
Test: FAILED
Status: 38 pre 25 11 post
Test: FAILED
Status: 21 pre 22 post
Test: FAILED
Status: 479 pre 80 397 post
Test: FAILED
Status: 12 pre 13 post
Test: FAILED
Status: 487 pre 423 62 post
Test: FAILED
Status: 94 pre 95 post
Test: FAILED
Status: 346 pre 242 102 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 468 pre 403 63 post
Test: FAILED
Status: 56 pre 57 post
Test: FAILED
Status: 376 pre 105 269 post
Test: FAILED
Status: 53 pre 54 post
Test: FAILED
Status: 332 pre 7 323 post
Test: FAILED
Status: 110 pre 111 post
Test: FAILED
Status: 378 pre 234 142 post
Test: FAILED
Status: 331 pre 332 post
Test: FAILED
Status: 69 pre 12 55 post
Test: FAILED
Status: 114 pre 115 post
Test: FAILED
Status: 68 pre 66 0 post
Test: FAILED
Status: 143 pre 144 post
Test: FAILED
Status: 337 pre 164 171 post
Test: FAILED
Status: 103 pre 104 post
Test: FAILED
Status: 385 pre 250 133 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 484 pre 286 196 post
Test: FAILED
Status: 147 pre 148 post
Test: FAILED
Status: 325 pre 269 54 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 485 pre 472 11 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 476 pre 421 53 post
Test: FAILED
Status: 17 pre 18 post
Test: FAILED
Status: 457 pre 191 264 post
Test: FAILED
Status: 242 pre 243 post
Test: FAILED
Status: 202 pre 55 145 post
Test: FAILED
Status: 115 pre 116 post
Test: FAILED
Status: 372 pre 273 97 post
Test: FAILED
Status: 41 pre 42 post
Test: FAILED
Status: 315 pre 306 7 post
Test: FAILED
Status: 55 pre 56 post
Test: FAILED
Status: 383 pre 381 0 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 437 pre 418 17 post
Test: FAILED
Status: 270 pre 271 post
Test: FAILED
Status: 225 pre 107 116 post
Test: FAILED
Status: 130 pre 131 post
Test: FAILED
Status: 322 pre 137 183 post
Test: FAILED
Status: 341 pre 342 post
Test: FAILED
Status: 138 pre 117 19 post
Test: FAILED
Status: 84 pre 85 post
Test: FAILED
Status: 387 pre 156 229 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 493 pre 43 448 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 468 pre 80 386 post
Test: FAILED
Status: 18 pre 19 post
Test: FAILED
Status: 462 pre 162 298 post
Test: FAILED
Status: 57 pre 58 post
Test: FAILED
Status: 325 pre 234 89 post
Test: FAILED
Status: 50 pre 51 post
Test: FAILED
Status: 262 pre 82 178 post
Test: FAILED
Status: 66 pre 67 post
Test: FAILED
Status: 311 pre 197 112 post
Test: FAILED
Status: 46 pre 47 post
Test: FAILED
Status: 211 pre 209 0 post
Test: FAILED
Status: 77 pre 78 post
Test: FAILED
Status: 215 pre 125 88 post
Test: FAILED
Status: 99 pre 100 post
Test: FAILED
Status: 333 pre 46 285 post
Test: FAILED
Status: 66 pre 67 post
Test: FAILED
Status: 335 pre 262 71 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 462 pre 417 43 post
Test: FAILED
Status: 180 pre 181 post
Test: FAILED
Status: 207 pre 149 56 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 498 pre 169 327 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 478 pre 325 151 post
Test: FAILED
Status: 95 pre 96 post
Test: FAILED
Status: 393 pre 348 43 post
Test: FAILED
Status: 12 pre 13 post
Test: FAILED
Status: 488 pre 486 0 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 414 pre 412 0 post
Test: FAILED
Status: 10 pre 11 post
Test: FAILED
Status: 411 pre 226 183 post
Test: FAILED
Status: 167 pre 168 post
Test: FAILED
Status: 306 pre 20 284 post
Test: FAILED
Status: 124 pre 125 post
Test: FAILED
Status: 211 pre 200 9 post
Test: FAILED
Status: 157 pre 158 post
Test: FAILED
Status: 293 pre 209 82 post
Test: FAILED
Status: 32 pre 33 post
Test: FAILED
Status: 281 pre 275 4 post
Test: FAILED
Status: 136 pre 137 post
Test: FAILED
Status: 248 pre 59 187 post
Test: FAILED
Status: 86 pre 87 post
Test: FAILED
Status: 381 pre 253 126 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 493 pre 491 0 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 420 pre 213 205 post
Test: FAILED
Status: 31 pre 32 post
Test: FAILED
Status: 439 pre 437 0 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 405 pre 62 341 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 447 pre 377 68 post
Test: FAILED
Status: 56 pre 57 post
Test: FAILED
Status: 406 pre 159 245 post
Test: FAILED
Status: 87 pre 88 post
Test: FAILED
Status: 294 pre 203 89 post
Test: FAILED
Status: 88 pre 89 post
Test: FAILED
Status: 389 pre 313 74 post
Test: FAILED
Status: 139 pre 140 post
Test: FAILED
Status: 250 pre 248 0 post
Test: FAILED
Status: 43 pre 44 post
Test: FAILED
Status: 402 pre 379 21 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 477 pre 356 119 post
Test: FAILED
Status: 24 pre 25 post
Test: FAILED
Status: 474 pre 425 47 post
Test: FAILED
Status: 74 pre 75 post
Test: FAILED
Status: 423 pre 276 145 post
Test: FAILED
Status: 86 pre 87 post
Test: FAILED
Status: 336 pre 329 5 post
Test: FAILED
Status: 92 pre 93 post
Test: FAILED
Status: 302 pre 207 93 post
Test: FAILED
Status: 60 pre 61 post
Test: FAILED
Status: 409 pre 330 77 post
Test: FAILED
Status: 43 pre 44 post
Test: FAILED
Status: 372 pre 117 253 post
Test: FAILED
Status: 152 pre 153 post
Test: FAILED
Status: 174 pre 115 57 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 473 pre 469 2 post
Test: FAILED
Status: 178 pre 179 post
Test: FAILED
Status: 283 pre 173 108 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 485 pre 483 0 post
Test: FAILED
Status: 63 pre 64 post
Test: FAILED
Status: 418 pre 32 384 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 485 pre 480 3 post
Test: FAILED
Status: 122 pre 123 post
Test: FAILED
Status: 308 pre 93 213 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 470 pre 247 221 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 458 pre 452 4 post
Test: FAILED
Status: 28 pre 29 post
Test: FAILED
Status: 455 pre 453 0 post
Test: FAILED
Status: 15 pre 16 post
Test: FAILED
Status: 480 pre 472 6 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 485 pre 479 4 post
Test: FAILED
Status: 81 pre 82 post
Test: FAILED
Status: 272 pre 208 62 post
Test: FAILED
Status: 10 pre 11 post
Test: FAILED
Status: 481 pre 479 0 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 263 pre 188 73 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 495 pre 459 34 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 448 pre 430 16 post
Test: FAILED
Status: 164 pre 165 post
Test: FAILED
Status: 277 pre 254 21 post
Test: FAILED
Status: 43 pre 44 post
Test: FAILED
Status: 242 pre 234 6 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 392 pre 386 4 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 464 pre 149 313 post
Test: FAILED
Status: 202 pre 203 post
Test: FAILED
Status: 260 pre 49 209 post
Test: FAILED
Status: 81 pre 82 post
Test: FAILED
Status: 403 pre 310 91 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 458 pre 394 62 post
Test: FAILED
Status: 187 pre 188 post
Test: FAILED
Status: 308 pre 29 277 post
Test: FAILED
Status: 46 pre 47 post
Test: FAILED
Status: 429 pre 83 344 post
Test: FAILED
Status: 44 pre 45 post
Test: FAILED
Status: 432 pre 430 0 post
Test: FAILED
Status: 65 pre 66 post
Test: FAILED
Status: 422 pre 397 23 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 318 pre 128 188 post
Test: FAILED
Status: 159 pre 160 post
Test: FAILED
Status: 318 pre 210 106 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 415 pre 370 43 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 458 pre 407 49 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 427 pre 297 128 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 481 pre 324 155 post
Test: FAILED
Status: 25 pre 26 post
Test: FAILED
Status: 278 pre 217 59 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 401 pre 188 211 post
Test: FAILED
Status: 135 pre 136 post
Test: FAILED
Status: 233 pre 17 214 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 493 pre 490 1 post
Test: FAILED
Status: 33 pre 34 post
Test: FAILED
Status: 466 pre 416 48 post
Test: FAILED
Status: 422 pre 423 post
Test: FAILED
Status: 40 pre 17 21 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 493 pre 488 3 post
Test: FAILED
Status: 113 pre 114 post
Test: FAILED
Status: 370 pre 220 148 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 480 pre 427 51 post
Test: FAILED
Status: 337 pre 338 post
Test: FAILED
Status: 136 pre 101 33 post
Test: FAILED
Status: 21 pre 22 post
Test: FAILED
Status: 465 pre 379 84 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 115 pre 17 96 post
Test: FAILED
Status: 40 pre 41 post
Test: FAILED
Status: 430 pre 425 3 post
Test: FAILED
Status: 23 pre 24 post
Test: FAILED
Status: 477 pre 424 51 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 493 pre 471 20 post
Test: FAILED
Status: 25 pre 26 post
Test: FAILED
Status: 219 pre 104 113 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 497 pre 494 1 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 497 pre 425 70 post
Test: FAILED
Status: 122 pre 123 post
Test: FAILED
Status: 342 pre 289 51 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 492 pre 482 8 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 214 pre 180 32 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 493 pre 491 0 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 498 pre 324 172 post
Test: FAILED
Status: 382 pre 383 post
Test: FAILED
Status: 44 pre 3 39 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 468 pre 455 11 post
Test: FAILED
Status: 72 pre 73 post
Test: FAILED
Status: 400 pre 320 78 post
Test: FAILED
Status: 80 pre 81 post
Test: FAILED
Status: 357 pre 12 343 post
Test: FAILED
Status: 21 pre 22 post
Test: FAILED
Status: 433 pre 412 19 post
Test: FAILED
Status: 242 pre 243 post
Test: FAILED
Status: 167 pre 146 19 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 440 pre 219 219 post
Test: FAILED
Status: 175 pre 176 post
Test: FAILED
Status: 251 pre 194 55 post
Test: FAILED
Status: 92 pre 93 post
Test: FAILED
Status: 396 pre 275 119 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 448 pre 212 234 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 495 pre 486 7 post
Test: FAILED
Status: 104 pre 105 post
Test: FAILED
Status: 378 pre 9 367 post
Test: FAILED
Status: 55 pre 56 post
Test: FAILED
Status: 431 pre 102 327 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 475 pre 433 40 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 479 pre 463 14 post
Test: FAILED
Status: 53 pre 54 post
Test: FAILED
Status: 422 pre 333 87 post
Test: FAILED
Status: 10 pre 11 post
Test: FAILED
Status: 463 pre 461 0 post
Test: FAILED
Status: 54 pre 55 post
Test: FAILED
Status: 376 pre 369 5 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 469 pre 382 85 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 216 pre 214 0 post
Test: FAILED
Status: 80 pre 81 post
Test: FAILED
Status: 361 pre 307 52 post
Test: FAILED
Status: 191 pre 192 post
Test: FAILED
Status: 232 pre 184 46 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 482 pre 45 435 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 487 pre 226 259 post
Test: FAILED
Status: 227 pre 228 post
Test: FAILED
Status: 36 pre 7 27 post
Test: FAILED
Status: 45 pre 46 post
Test: FAILED
Status: 426 pre 419 5 post
Test: FAILED
Status: 39 pre 40 post
Test: FAILED
Status: 414 pre 392 20 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 460 pre 229 229 post
Test: FAILED
Status: 142 pre 143 post
Test: FAILED
Status: 183 pre 99 82 post
Test: FAILED
Status: 234 pre 235 post
Test: FAILED
Status: 250 pre 5 243 post
Test: FAILED
Status: 71 pre 72 post
Test: FAILED
Status: 275 pre 273 0 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 449 pre 50 397 post
Test: FAILED
Status: 191 pre 192 post
Test: FAILED
Status: 272 pre 155 115 post
Test: FAILED
Status: 79 pre 80 post
Test: FAILED
Status: 394 pre 271 121 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 397 pre 67 328 post
Test: FAILED
Status: 90 pre 91 post
Test: FAILED
Status: 385 pre 279 104 post
Test: FAILED
Status: 214 pre 215 post
Test: FAILED
Status: 224 pre 75 147 post
Test: FAILED
Status: 15 pre 16 post
Test: FAILED
Status: 478 pre 470 6 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 496 pre 494 0 post
Test: FAILED
Status: 94 pre 95 post
Test: FAILED
Status: 344 pre 342 0 post
Test: FAILED
Status: 67 pre 68 post
Test: FAILED
Status: 405 pre 232 171 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 477 pre 474 1 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 495 pre 493 0 post
Test: FAILED
Status: 77 pre 78 post
Test: FAILED
Status: 379 pre 338 39 post
Test: FAILED
Status: 71 pre 72 post
Test: FAILED
Status: 408 pre 366 40 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 390 pre 388 0 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 498 pre 409 87 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 403 pre 362 39 post
Test: FAILED
Status: 73 pre 74 post
Test: FAILED
Status: 348 pre 216 130 post
Test: FAILED
Status: 83 pre 84 post
Test: FAILED
Status: 368 pre 352 14 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 417 pre 98 317 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 496 pre 494 0 post
Test: FAILED
Status: 237 pre 238 post
Test: FAILED
Status: 188 pre 86 100 post
Test: FAILED
Status: 133 pre 134 post
Test: FAILED
Status: 301 pre 28 271 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 480 pre 438 40 post
Test: FAILED
Status: 37 pre 38 post
Test: FAILED
Status: 454 pre 295 157 post
Test: FAILED
Status: 5 pre 6 post
Test: FAILED
Status: 494 pre 492 0 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 486 pre 279 205 post
Test: FAILED
Status: 78 pre 79 post
Test: FAILED
Status: 275 pre 273 0 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 475 pre 439 34 post
Test: FAILED
Status: 157 pre 158 post
Test: FAILED
Status: 331 pre 329 0 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 419 pre 368 49 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 300 pre 218 80 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 478 pre 462 14 post
Test: FAILED
Status: 243 pre 244 post
Test: FAILED
Status: 171 pre 159 10 post
Test: FAILED
Status: 190 pre 191 post
Test: FAILED
Status: 302 pre 216 84 post
Test: FAILED
Status: 115 pre 116 post
Test: FAILED
Status: 317 pre 288 27 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 479 pre 400 77 post
Test: FAILED
Status: 93 pre 94 post
Test: FAILED
Status: 395 pre 101 292 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 492 pre 467 23 post
Test: FAILED
Status: 28 pre 29 post
Test: FAILED
Status: 374 pre 354 18 post
Test: FAILED
Status: 96 pre 97 post
Test: FAILED
Status: 388 pre 105 281 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 435 pre 375 58 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 495 pre 470 23 post
Test: FAILED
Status: 90 pre 91 post
Test: FAILED
Status: 359 pre 238 119 post
Test: FAILED
Status: 190 pre 191 post
Test: FAILED
Status: 305 pre 28 275 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 437 pre 435 0 post
Test: FAILED
Status: 37 pre 38 post
Test: FAILED
Status: 358 pre 180 176 post
Test: FAILED
Status: 39 pre 40 post
Test: FAILED
Status: 408 pre 259 147 post
Test: FAILED
Status: 221 pre 222 post
Test: FAILED
Status: 276 pre 24 250 post
Test: FAILED
Status: 93 pre 94 post
Test: FAILED
Status: 369 pre 58 309 post
Test: FAILED
Status: 303 pre 304 post
Test: FAILED
Status: 139 pre 62 75 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 422 pre 133 287 post
Test: FAILED
Status: 50 pre 51 post
Test: FAILED
Status: 355 pre 291 62 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 489 pre 485 2 post
Test: FAILED
Status: 61 pre 62 post
Test: FAILED
Status: 368 pre 106 260 post
Test: FAILED
Status: 15 pre 16 post
Test: FAILED
Status: 464 pre 115 347 post
Test: FAILED
Status: 177 pre 178 post
Test: FAILED
Status: 140 pre 11 127 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 464 pre 383 79 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 493 pre 427 64 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 373 pre 332 39 post
Test: FAILED
Status: 35 pre 36 post
Test: FAILED
Status: 453 pre 365 86 post
Test: FAILED
Status: 179 pre 180 post
Test: FAILED
Status: 256 pre 175 79 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 498 pre 444 52 post
Test: FAILED
Status: 22 pre 23 post
Test: FAILED
Status: 425 pre 423 0 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 496 pre 390 104 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 491 pre 454 35 post
Test: FAILED
Status: 76 pre 77 post
Test: FAILED
Status: 241 pre 208 31 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 471 pre 302 167 post
Test: FAILED
Status: 48 pre 49 post
Test: FAILED
Status: 159 pre 97 60 post
Test: FAILED
Status: 140 pre 141 post
Test: FAILED
Status: 292 pre 289 1 post
Test: FAILED
Status: 99 pre 100 post
Test: FAILED
Status: 365 pre 245 118 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 487 pre 355 130 post
Test: FAILED
Status: 44 pre 45 post
Test: FAILED
Status: 417 pre 415 0 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 451 pre 449 0 post
Test: FAILED
Status: 159 pre 160 post
Test: FAILED
Status: 257 pre 17 238 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 498 pre 63 433 post
Test: FAILED
Status: 188 pre 189 post
Test: FAILED
Status: 260 pre 214 44 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 492 pre 377 113 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 284 pre 189 93 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 456 pre 381 73 post
Test: FAILED
Status: 33 pre 34 post
Test: FAILED
Status: 438 pre 246 190 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 393 pre 248 143 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 234 pre 156 76 post
Test: FAILED
Status: 42 pre 43 post
Test: FAILED
Status: 447 pre 411 34 post
Test: FAILED
Status: 70 pre 71 post
Test: FAILED
Status: 426 pre 373 51 post
Test: FAILED
Status: 19 pre 20 post
Test: FAILED
Status: 463 pre 166 295 post
Test: FAILED
Status: 244 pre 245 post
Test: FAILED
Status: 169 pre 103 64 post
Test: FAILED
Status: 70 pre 71 post
Test: FAILED
Status: 386 pre 110 274 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 494 pre 490 2 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 425 pre 419 4 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 422 pre 390 30 post
Test: FAILED
Status: 86 pre 87 post
Test: FAILED
Status: 399 pre 112 285 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 220 pre 218 0 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 485 pre 447 36 post
Test: FAILED
Status: 94 pre 95 post
Test: FAILED
Status: 113 pre 107 4 post
Test: FAILED
Status: 23 pre 24 post
Test: FAILED
Status: 151 pre 28 121 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 441 pre 254 185 post
Test: FAILED
Status: 25 pre 26 post
Test: FAILED
Status: 414 pre 137 275 post
Test: FAILED
Status: 73 pre 74 post
Test: FAILED
Status: 410 pre 364 44 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 475 pre 379 94 post
Test: FAILED
Status: 53 pre 54 post
Test: FAILED
Status: 304 pre 53 249 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 488 pre 486 0 post
Test: FAILED
Status: 66 pre 67 post
Test: FAILED
Status: 424 pre 337 85 post
Test: FAILED
Status: 289 pre 290 post
Test: FAILED
Status: 77 pre 42 33 post
Test: FAILED
Status: 78 pre 79 post
Test: FAILED
Status: 351 pre 268 81 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 373 pre 313 58 post
Test: FAILED
Status: 83 pre 84 post
Test: FAILED
Status: 378 pre 294 82 post
Test: FAILED
Status: 10 pre 11 post
Test: FAILED
Status: 474 pre 457 15 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 486 pre 477 7 post
Test: FAILED
Status: 94 pre 95 post
Test: FAILED
Status: 381 pre 231 148 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 436 pre 394 40 post
Test: FAILED
Status: 24 pre 25 post
Test: FAILED
Status: 434 pre 296 136 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 485 pre 268 215 post
Test: FAILED
Status: 213 pre 214 post
Test: FAILED
Status: 245 pre 212 31 post
Test: FAILED
Status: 55 pre 56 post
Test: FAILED
Status: 271 pre 247 22 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 479 pre 403 74 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 493 pre 456 35 post
Test: FAILED
Status: 12 pre 13 post
Test: FAILED
Status: 483 pre 321 160 post
Test: FAILED
Status: 108 pre 109 post
Test: FAILED
Status: 381 pre 371 8 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 492 pre 488 2 post
Test: FAILED
Status: 20 pre 21 post
Test: FAILED
Status: 476 pre 340 134 post
Test: FAILED
Status: 156 pre 157 post
Test: FAILED
Status: 249 pre 242 5 post
Test: FAILED
Status: 58 pre 59 post
Test: FAILED
Status: 177 pre 144 31 post
Test: FAILED
Status: 122 pre 123 post
Test: FAILED
Status: 323 pre 233 88 post
Test: FAILED
Status: 89 pre 90 post
Test: FAILED
Status: 399 pre 213 184 post
Test: FAILED
Status: 60 pre 61 post
Test: FAILED
Status: 384 pre 116 266 post
Test: FAILED
Status: 30 pre 31 post
Test: FAILED
Status: 382 pre 287 93 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 438 pre 118 318 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 481 pre 108 371 post
Test: FAILED
Status: 164 pre 165 post
Test: FAILED
Status: 334 pre 223 109 post
Test: FAILED
Status: 156 pre 157 post
Test: FAILED
Status: 342 pre 167 173 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 283 pre 280 1 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 217 pre 213 2 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 437 pre 435 0 post
Test: FAILED
Status: 154 pre 155 post
Test: FAILED
Status: 265 pre 195 68 post
Test: FAILED
Status: 142 pre 143 post
Test: FAILED
Status: 337 pre 324 11 post
Test: FAILED
Status: 146 pre 147 post
Test: FAILED
Status: 70 pre 23 45 post
Test: FAILED
Status: 110 pre 111 post
Test: FAILED
Status: 274 pre 209 63 post
Test: FAILED
Status: 104 pre 105 post
Test: FAILED
Status: 365 pre 256 107 post
Test: FAILED
Status: 132 pre 133 post
Test: FAILED
Status: 251 pre 141 108 post
Test: FAILED
Status: 9 pre 10 post
Test: FAILED
Status: 483 pre 142 339 post
Test: FAILED
Status: 83 pre 84 post
Test: FAILED
Status: 259 pre 204 53 post
Test: FAILED
Status: 61 pre 62 post
Test: FAILED
Status: 431 pre 310 119 post
Test: FAILED
Status: 83 pre 84 post
Test: FAILED
Status: 339 pre 256 81 post
Test: FAILED
Status: 136 pre 137 post
Test: FAILED
Status: 266 pre 264 0 post
Test: FAILED
Status: 17 pre 18 post
Test: FAILED
Status: 480 pre 447 31 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 360 pre 199 159 post
Test: FAILED
Status: 152 pre 153 post
Test: FAILED
Status: 293 pre 104 187 post
Test: FAILED
Status: 43 pre 44 post
Test: FAILED
Status: 378 pre 351 25 post
Test: FAILED
Status: 12 pre 13 post
Test: FAILED
Status: 423 pre 23 398 post
Test: FAILED
Status: 49 pre 50 post
Test: FAILED
Status: 431 pre 189 240 post
Test: FAILED
Status: 6 pre 7 post
Test: FAILED
Status: 486 pre 466 18 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 488 pre 396 90 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 399 pre 168 229 post
Test: FAILED
Status: 2 pre 3 post
Test: FAILED
Status: 492 pre 461 29 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 446 pre 444 0 post
Test: FAILED
Status: 80 pre 81 post
Test: FAILED
Status: 402 pre 273 127 post
Test: FAILED
Status: 80 pre 81 post
Test: FAILED
Status: 309 pre 232 75 post
Test: FAILED
Status: 4 pre 5 post
Test: FAILED
Status: 432 pre 305 125 post
Test: FAILED
Status: 25 pre 26 post
Test: FAILED
Status: 467 pre 372 93 post
Test: FAILED
Status: 56 pre 57 post
Test: FAILED
Status: 221 pre 5 214 post
Test: FAILED
Status: 27 pre 28 post
Test: FAILED
Status: 413 pre 333 78 post
Test: FAILED
Status: 129 pre 130 post
Test: FAILED
Status: 197 pre 181 14 post
Test: FAILED
Status: 72 pre 73 post
Test: FAILED
Status: 409 pre 381 26 post
Test: FAILED
Status: 168 pre 169 post
Test: FAILED
Status: 228 pre 133 93 post
Test: FAILED
Status: 65 pre 66 post
Test: FAILED
Status: 368 pre 290 76 post
Test: FAILED
Status: 31 pre 32 post
Test: FAILED
Status: 383 pre 269 112 post
Test: FAILED
Status: 8 pre 9 post
Test: FAILED
Status: 484 pre 482 0 post
Test: FAILED
Status: 67 pre 68 post
Test: FAILED
Status: 408 pre 70 336 post
Test: FAILED
Status: 3 pre 4 post
Test: FAILED
Status: 493 pre 491 0 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 436 pre 434 0 post
Test: FAILED
Status: 11 pre 12 post
Test: FAILED
Status: 483 pre 468 13 post
Test: FAILED
Status: 105 pre 106 post
Test: FAILED
Status: 308 pre 121 185 post
Test: FAILED
Status: 7 pre 8 post
Test: FAILED
Status: 467 pre 448 17 post
Test: FAILED
Status: 44 pre 45 post
Test: FAILED
Status: 379 pre 277 100 post
Test: FAILED
Status: 28 pre 29 post
Test: FAILED
Status: 192 pre 106 84 post
Test: FAILED
Status: 29 pre 30 post
Test: FAILED
Status: 467 pre 461 4 post
Test: FAILED
Status: 17 pre 18 post
Test: FAILED
Status: 479 pre 464 13 post
Test: FAILED
Status: 13 pre 14 post
Test: FAILED
Status: 303 pre 161 140 post
Test: FAILED
Status: 109 pre 110 post
Test: FAILED
Status: 139 pre 77 60 post
Test: FAILED
Status: 48 pre 49 post
Test: FAILED
Status: 450 pre 239 209 post
Test: FAILED
Status: 14 pre 15 post
Test: FAILED
Status: 452 pre 410 40 post
Test: FAILED
Status: 46 pre 47 post
Test: FAILED
Status: 362 pre 325 35 post
Test: FAILED
Status: 38 pre 39 post
Test: FAILED
Status: 399 pre 86 311 post
Test: FAILED
Status: 107 pre 108 post
Test: FAILED
Status: 293 pre 191 100 post
Test: FAILED
Status: 36 pre 37 post
Test: FAILED
Status: 322 pre 69 251 post
Test: FAILED
Status: 103 pre 104 post
Test: FAILED
Status: 377 pre 368 7 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 468 pre 463 3 post
Test: FAILED
Status: 17 pre 18 post
Test: FAILED
Status: 481 pre 273 206 post
Test: FAILED
Status: 124 pre 125 post
Test: FAILED
Status: 189 pre 148 39 post
Test: FAILED
Status: 26 pre 27 post
Test: FAILED
Status: 432 pre 430 0 post
Test: FAILED
Status: 59 pre 60 post
Test: FAILED
Status: 290 pre 232 56 post
Test: FAILED
Status: 269 pre 270 post
Test: FAILED
Status: 221 pre 219 0 post
Test: FAILED
Status: 25 pre 26 post
Test: FAILED
Status: 444 pre 355 87 post
Test: FAILED
Status: 265 pre 266 post
Test: FAILED
Status: 88 pre 74 12 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 494 pre 492 0 post
Test: FAILED
Status: 1 pre 2 post
Test: FAILED
Status: 498 pre 260 236 post
Test: FAILED
Status: 98 pre 99 post
Test: FAILED
Status: 272 pre 135 135 post
Test: FAILED
Status: 18 pre 19 post
Test: FAILED
Status: 467 pre 304 161 post
Test: FAILED
Status: 187 pre 188 post
Test: FAILED
Status: 273 pre 165 106 post
Test: FAILED
Status: 1000 failures of the playSmithy
File 'randomtestcard1.c'
Lines executed:97.78% of 45
Creating 'randomtestcard1.c.gcov'

File 'dominion.c'
Lines executed:24.11% of 564
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
  1043010:    8:int compare(const void* a, const void* b) {
  1043010:    9:  if (*(int*)a > *(int*)b)
   515776:   10:    return 1;
   527234:   11:  if (*(int*)a < *(int*)b)
   232340:   12:    return -1;
   294894:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
    #####:   18:      drawCard(currentPlayer, state);
        -:   19:			
        -:   20:      //+2 Actions
    #####:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
    #####:   24:      discardCard(handPos, currentPlayer, state, 0);
    #####:   25:}
        -:   26:
      500:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
     1500:   29:    for (i = 1; i < 3; i++)
        -:   30:	{
     1000:   31:	  drawCard(currentPlayer, state);
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
      500:   36:      discardCard(handPos, currentPlayer, state, 0);
        -:   37: 
        -:   38:
      500:   39:}
    #####:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
    #####:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
    #####:   44:int z = 0;
    #####:   45:while(drawntreasure<2){
    #####:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####:   47:	  shuffle(currentPlayer, state);
        -:   48:	}
    #####:   49:	drawCard(currentPlayer, state);
        -:   50:
    #####:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   52:	if (cardDrawn == copper || cardDrawn == silver)
    #####:   53:	  drawntreasure++;
        -:   54:	else{
    #####:   55:	  temphand[z]=cardDrawn;
    #####:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   57:	  z++;
        -:   58:	}
        -:   59:      }
    #####:   60:      while(z-1>=0){
    #####:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   62:	z=z-1;
    #####:   63:      }}
        -:   64:
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
    #####:   91:		isGameOver(state);
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
    #####:  108:	    isGameOver(state);
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
    #####:  121:	  drawCard(currentPlayer, state);
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
    #####:  139:}
        -:  140:
        -:  141:
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
      500:  171:  PutSeed((long)randomSeed);
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:  175:    {
      261:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      239:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2629:  183:  for (i = 0; i < 10; i++)
        -:  184:    {
    26290:  185:      for (j = 0; j < 10; j++)
        -:  186:        {
    23900:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      239:  199:  if (numPlayers == 2)
        -:  200:    {
      123:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      116:  203:  else if (numPlayers == 3)
        -:  204:    {
      116:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      239:  213:  if (numPlayers == 2)
        -:  214:    {
      123:  215:      state->supplyCount[estate] = 8;
      123:  216:      state->supplyCount[duchy] = 8;
      123:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      116:  221:      state->supplyCount[estate] = 12;
      116:  222:      state->supplyCount[duchy] = 12;
      116:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      239:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      239:  228:  state->supplyCount[silver] = 40;
      239:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5019:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  233:    {
    39435:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  235:	{
    37045:  236:	  if (kingdomCards[j] == i)
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2390:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  240:		{
      478:  241:		  if (numPlayers == 2){ 
      123:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      116:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2151:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2390:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    34655:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      833:  264:  for (i = 0; i < numPlayers; i++)
        -:  265:    {
      594:  266:      state->deckCount[i] = 0;
     2376:  267:      for (j = 0; j < 3; j++)
        -:  268:	{
     1782:  269:	  state->deck[i][j] = estate;
     1782:  270:	  state->deckCount[i]++;
        -:  271:	}
     4752:  272:      for (j = 3; j < 10; j++)
        -:  273:	{
     4158:  274:	  state->deck[i][j] = copper;
     4158:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      833:  280:  for (i = 0; i < numPlayers; i++)
        -:  281:    {
      594:  282:      if ( shuffle(i, state) < 0 )
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      833:  289:  for (i = 0; i < numPlayers; i++)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      594:  292:      state->handCount[i] = 0;
      594:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6692:  302:  for (i = 0; i <= treasure_map; i++)
        -:  303:    {
     6453:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      239:  308:  state->outpostPlayed = 0;
      239:  309:  state->phase = 0;
      239:  310:  state->numActions = 1;
      239:  311:  state->numBuys = 1;
      239:  312:  state->playedCardCount = 0;
      239:  313:  state->whoseTurn = 0;
      239:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1434:  318:  for (it = 0; it < 5; it++){
     1195:  319:    drawCard(state->whoseTurn, state);
        -:  320:  }
        -:  321:
      239:  322:  updateCoins(state->whoseTurn, state, 0);
        -:  323:
      239:  324:  return 0;
        -:  325:}
        -:  326:
     1141:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1141:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1141:  335:  if (state->deckCount[player] < 1)
    #####:  336:    return -1;
     1141:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   155335:  340:  while (state->deckCount[player] > 0) {
   153053:  341:    card = floor(Random() * state->deckCount[player]);
   153053:  342:    newDeck[newDeckPos] = state->deck[player][card];
   153053:  343:    newDeckPos++;
 12968734:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
 12815681:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   153053:  347:    state->deckCount[player]--;
        -:  348:  }
   154194:  349:  for (i = 0; i < newDeckPos; i++) {
   153053:  350:    state->deck[player][i] = newDeck[i];
   153053:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1141:  354:  return 0;
        -:  355:}
        -:  356:
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
        -:  439:}
        -:  440:
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
     2195:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
     2195:  654:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    19004:  659:    for (i = 0; i < state->discardCount[player];i++){
    18957:  660:      state->deck[player][i] = state->discard[player][i];
    18957:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       47:  664:    state->deckCount[player] = state->discardCount[player];
       47:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       47:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       47:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       47:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       47:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       47:  685:    if (deckCounter == 0)
    #####:  686:      return -1;
        -:  687:
       47:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       47:  689:    state->deckCount[player]--;
       47:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
     2148:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
     2148:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
     2148:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     2148:  702:    state->deckCount[player]--;
     2148:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
     2195:  706:  return 0;
        -:  707:}
        -:  708:
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
        -:  794:    {
        -:  795:    case adventurer:
    #####:  796:      playAdventurer(currentPlayer, state, handPos);
    #####:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
    #####:  836:	if (supplyCount(choice1, state) <= 0){
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
    #####:  845:	  printf("That card is too expensive!\n");
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
      500:  943:      playSmithy(currentPlayer, state, handPos);
      500:  944:      return 0;
        -:  945:
        -:  946:    case village:
    #####:  947:      playVillage(currentPlayer, state, handPos);
    #####:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1070:	  drawCard(currentPlayer, state);
    #####: 1071:	  drawCard(currentPlayer, state);
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
    #####: 1216:	if (i != currentPlayer){
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
      500: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
      500: 1262:  if (trashFlag < 1)
        -: 1263:    {
        -: 1264:      //add card to played pile
      500: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      500: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
      500: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
      500: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
      500: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
      500: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
      500: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
      500: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
      500: 1293:  return 0;
        -: 1294:}
        -: 1295:
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
      239: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      239: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1434: 1341:  for (i = 0; i < state->handCount[player]; i++)
        -: 1342:    {
     1195: 1343:      if (state->hand[player][i] == copper)
        -: 1344:	{
      825: 1345:	  state->coins += 1;
        -: 1346:	}
      370: 1347:      else if (state->hand[player][i] == silver)
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      370: 1351:      else if (state->hand[player][i] == gold)
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      239: 1358:  state->coins += bonus;
        -: 1359:
      239: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
File 'randomtestcard1.c'
Lines executed:97.78% of 45
Branches executed:100.00% of 16
Taken at least once:93.75% of 16
Calls executed:95.45% of 22
Creating 'randomtestcard1.c.gcov'

File 'dominion.c'
Lines executed:24.11% of 564
Branches executed:24.82% of 415
Taken at least once:16.87% of 415
Calls executed:12.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1043010 returned 100% blocks executed 100%
  1043010:    8:int compare(const void* a, const void* b) {
  1043010:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 515776 (fallthrough)
branch  1 taken 527234
   515776:   10:    return 1;
   527234:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 232340 (fallthrough)
branch  1 taken 294894
   232340:   12:    return -1;
   294894:   13:  return 0;
        -:   14:}
        -:   15:
function playVillage called 0 returned 0% blocks executed 0%
    #####:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
    #####:   18:      drawCard(currentPlayer, state);
call    0 never executed
        -:   19:			
        -:   20:      //+2 Actions
    #####:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
    #####:   24:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:   25:}
        -:   26:
function playSmithy called 500 returned 100% blocks executed 100%
      500:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
     1500:   29:    for (i = 1; i < 3; i++)
branch  0 taken 1000
branch  1 taken 500 (fallthrough)
        -:   30:	{
     1000:   31:	  drawCard(currentPlayer, state);
call    0 returned 1000
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
      500:   36:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 500
        -:   37: 
        -:   38:
      500:   39:}
function playAdventurer called 0 returned 0% blocks executed 0%
    #####:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
    #####:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
    #####:   44:int z = 0;
    #####:   45:while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:   47:	  shuffle(currentPlayer, state);
call    0 never executed
        -:   48:	}
    #####:   49:	drawCard(currentPlayer, state);
call    0 never executed
        -:   50:
    #####:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   52:	if (cardDrawn == copper || cardDrawn == silver)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   53:	  drawntreasure++;
        -:   54:	else{
    #####:   55:	  temphand[z]=cardDrawn;
    #####:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   57:	  z++;
        -:   58:	}
        -:   59:      }
    #####:   60:      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   62:	z=z-1;
    #####:   63:      }}
        -:   64:
function playBaron called 0 returned 0% blocks executed 0%
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   91:		isGameOver(state);
call    0 never executed
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:	    isGameOver(state);
call    0 never executed
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
function playSteward called 0 returned 0% blocks executed 0%
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  121:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####:  139:}
        -:  140:
        -:  141:
function newGame called 0 returned 0% blocks executed 0%
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
function initializeGame called 500 returned 100% blocks executed 95%
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
call    0 returned 500
      500:  171:  PutSeed((long)randomSeed);
call    0 returned 500
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 500 (fallthrough)
branch  1 taken 0
branch  2 taken 261 (fallthrough)
branch  3 taken 239
        -:  175:    {
      261:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      239:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2629:  183:  for (i = 0; i < 10; i++)
branch  0 taken 2390
branch  1 taken 239 (fallthrough)
        -:  184:    {
    26290:  185:      for (j = 0; j < 10; j++)
branch  0 taken 23900
branch  1 taken 2390 (fallthrough)
        -:  186:        {
    23900:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 21510 (fallthrough)
branch  1 taken 2390
branch  2 taken 0 (fallthrough)
branch  3 taken 21510
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      239:  199:  if (numPlayers == 2)
branch  0 taken 123 (fallthrough)
branch  1 taken 116
        -:  200:    {
      123:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      116:  203:  else if (numPlayers == 3)
branch  0 taken 116 (fallthrough)
branch  1 taken 0
        -:  204:    {
      116:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      239:  213:  if (numPlayers == 2)
branch  0 taken 123 (fallthrough)
branch  1 taken 116
        -:  214:    {
      123:  215:      state->supplyCount[estate] = 8;
      123:  216:      state->supplyCount[duchy] = 8;
      123:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      116:  221:      state->supplyCount[estate] = 12;
      116:  222:      state->supplyCount[duchy] = 12;
      116:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      239:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      239:  228:  state->supplyCount[silver] = 40;
      239:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5019:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 4780
branch  1 taken 239 (fallthrough)
        -:  233:    {
    39435:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 37045
branch  1 taken 2390 (fallthrough)
        -:  235:	{
    37045:  236:	  if (kingdomCards[j] == i)
branch  0 taken 2390 (fallthrough)
branch  1 taken 34655
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2390:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 2151 (fallthrough)
branch  1 taken 239
branch  2 taken 0 (fallthrough)
branch  3 taken 2151
        -:  240:		{
      478:  241:		  if (numPlayers == 2){ 
branch  0 taken 123 (fallthrough)
branch  1 taken 116
      123:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      116:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2151:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2390:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    34655:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      833:  264:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  265:    {
      594:  266:      state->deckCount[i] = 0;
     2376:  267:      for (j = 0; j < 3; j++)
branch  0 taken 1782
branch  1 taken 594 (fallthrough)
        -:  268:	{
     1782:  269:	  state->deck[i][j] = estate;
     1782:  270:	  state->deckCount[i]++;
        -:  271:	}
     4752:  272:      for (j = 3; j < 10; j++)
branch  0 taken 4158
branch  1 taken 594 (fallthrough)
        -:  273:	{
     4158:  274:	  state->deck[i][j] = copper;
     4158:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      833:  280:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  281:    {
      594:  282:      if ( shuffle(i, state) < 0 )
call    0 returned 594
branch  1 taken 0 (fallthrough)
branch  2 taken 594
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      833:  289:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      594:  292:      state->handCount[i] = 0;
      594:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6692:  302:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 6453
branch  1 taken 239 (fallthrough)
        -:  303:    {
     6453:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      239:  308:  state->outpostPlayed = 0;
      239:  309:  state->phase = 0;
      239:  310:  state->numActions = 1;
      239:  311:  state->numBuys = 1;
      239:  312:  state->playedCardCount = 0;
      239:  313:  state->whoseTurn = 0;
      239:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1434:  318:  for (it = 0; it < 5; it++){
branch  0 taken 1195
branch  1 taken 239 (fallthrough)
     1195:  319:    drawCard(state->whoseTurn, state);
call    0 returned 1195
        -:  320:  }
        -:  321:
      239:  322:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 239
        -:  323:
      239:  324:  return 0;
        -:  325:}
        -:  326:
function shuffle called 1141 returned 100% blocks executed 94%
     1141:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1141:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1141:  335:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1141
    #####:  336:    return -1;
     1141:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 1141
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   155335:  340:  while (state->deckCount[player] > 0) {
branch  0 taken 153053
branch  1 taken 1141 (fallthrough)
   153053:  341:    card = floor(Random() * state->deckCount[player]);
call    0 returned 153053
   153053:  342:    newDeck[newDeckPos] = state->deck[player][card];
   153053:  343:    newDeckPos++;
 12968734:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 12815681
branch  1 taken 153053 (fallthrough)
 12815681:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   153053:  347:    state->deckCount[player]--;
        -:  348:  }
   154194:  349:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 153053
branch  1 taken 1141 (fallthrough)
   153053:  350:    state->deck[player][i] = newDeck[i];
   153053:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1141:  354:  return 0;
        -:  355:}
        -:  356:
function playCard called 0 returned 0% blocks executed 0%
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
call    0 never executed
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  439:}
        -:  440:
function handCard called 0 returned 0% blocks executed 0%
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
function whoseTurn called 500 returned 100% blocks executed 100%
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
function drawCard called 2195 returned 100% blocks executed 92%
     2195:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
     2195:  654:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 47 (fallthrough)
branch  1 taken 2148
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    19004:  659:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 18957
branch  1 taken 47 (fallthrough)
    18957:  660:      state->deck[player][i] = state->discard[player][i];
    18957:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       47:  664:    state->deckCount[player] = state->discardCount[player];
       47:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       47:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 47
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       47:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       47:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       47:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       47:  685:    if (deckCounter == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 47
    #####:  686:      return -1;
        -:  687:
       47:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       47:  689:    state->deckCount[player]--;
       47:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
     2148:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
     2148:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
     2148:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     2148:  702:    state->deckCount[player]--;
     2148:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
     2195:  706:  return 0;
        -:  707:}
        -:  708:
function getCost called 0 returned 0% blocks executed 0%
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
function cardEffect called 500 returned 100% blocks executed 3%
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
call    0 returned 500
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    #####:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 500
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
        -:  794:    {
        -:  795:    case adventurer:
    #####:  796:      playAdventurer(currentPlayer, state, handPos);
call    0 never executed
    #####:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
call    0 never executed
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  836:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
      500:  943:      playSmithy(currentPlayer, state, handPos);
call    0 returned 500
      500:  944:      return 0;
        -:  945:
        -:  946:    case village:
    #####:  947:      playVillage(currentPlayer, state, handPos);
call    0 never executed
    #####:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
call    0 never executed
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
call    0 never executed
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
call    0 never executed
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
call    0 never executed
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1070:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1071:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1216:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
function discardCard called 500 returned 100% blocks executed 78%
      500: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
      500: 1262:  if (trashFlag < 1)
branch  0 taken 500 (fallthrough)
branch  1 taken 0
        -: 1263:    {
        -: 1264:      //add card to played pile
      500: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      500: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
      500: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
      500: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0 (fallthrough)
branch  1 taken 500
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
      500: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0 (fallthrough)
branch  1 taken 500
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
      500: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
      500: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
      500: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
      500: 1293:  return 0;
        -: 1294:}
        -: 1295:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
function updateCoins called 239 returned 100% blocks executed 82%
      239: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      239: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1434: 1341:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 1195
branch  1 taken 239 (fallthrough)
        -: 1342:    {
     1195: 1343:      if (state->hand[player][i] == copper)
branch  0 taken 825 (fallthrough)
branch  1 taken 370
        -: 1344:	{
      825: 1345:	  state->coins += 1;
        -: 1346:	}
      370: 1347:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      370: 1351:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      239: 1358:  state->coins += bonus;
        -: 1359:
      239: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
randomtestcard2.c:
playVillage() random test
Test: PASSED
Status: 246 pre 142 103 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 485 7 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 484 pre 470 13 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 442 pre 43 398 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 297 pre 58 238 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 463 pre 429 33 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 477 pre 455 21 post
Test: PASSED
Status: 13 pre 15 post
Test: PASSED
Test: PASSED
Status: 85 pre 22 62 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 158 pre 140 17 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 354 pre 256 97 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 416 pre 68 347 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 440 pre 406 33 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 417 pre 319 97 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 380 pre 379 0 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 327 pre 151 175 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 332 pre 115 216 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 344 pre 186 157 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 366 pre 109 256 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 438 pre 85 352 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 497 pre 490 6 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 472 pre 76 395 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 494 pre 493 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 473 pre 471 1 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 434 pre 62 371 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 399 pre 398 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 404 pre 352 51 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 365 pre 322 42 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 288 pre 287 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 371 pre 274 96 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 447 pre 386 60 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 471 pre 465 5 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 362 pre 103 258 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 357 pre 356 0 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 359 pre 177 181 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 300 pre 215 84 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 399 pre 341 57 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 52 pre 51 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 482 pre 264 217 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 408 pre 407 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 459 pre 415 43 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 337 pre 102 234 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 223 pre 164 58 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 215 pre 183 31 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 453 pre 431 21 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 143 pre 18 124 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 446 pre 444 1 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 477 pre 365 111 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 62 pre 12 49 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 460 pre 447 12 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 388 pre 74 313 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 443 pre 416 26 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 314 pre 69 244 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 485 pre 464 20 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 473 pre 467 5 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 378 pre 243 134 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 412 pre 150 261 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 308 pre 129 178 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 368 pre 72 295 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 451 pre 450 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 429 pre 127 301 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 432 pre 425 6 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 464 pre 332 131 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 496 pre 373 122 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 236 pre 98 137 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 391 pre 63 327 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 498 pre 492 5 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 99 pre 12 86 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 481 pre 439 41 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 136 pre 102 33 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 322 pre 321 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 278 pre 204 73 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 271 pre 163 107 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 474 pre 416 57 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 300 pre 295 4 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 89 pre 46 42 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 320 pre 268 51 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 496 pre 222 273 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 470 pre 469 0 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 258 pre 158 99 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 481 pre 369 111 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 98 pre 82 15 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 497 pre 496 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 447 pre 446 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 123 pre 112 10 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 390 pre 296 93 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 212 pre 96 115 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 293 pre 254 38 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 489 pre 488 0 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 494 pre 493 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 487 pre 312 174 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 472 pre 437 34 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 176 pre 166 9 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 358 pre 354 3 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 495 pre 488 6 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 467 pre 439 27 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 411 pre 293 117 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 386 pre 315 70 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 491 pre 480 10 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 461 pre 387 73 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 333 pre 236 96 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 143 pre 9 133 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 373 pre 331 41 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 462 pre 256 205 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 489 pre 413 75 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 255 pre 167 87 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 404 pre 28 375 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 347 pre 73 273 post
Test: PASSED
Status: 13 pre 15 post
Test: PASSED
Test: PASSED
Status: 474 pre 174 299 post
Test: PASSED
Status: 15 pre 17 post
Test: PASSED
Test: PASSED
Status: 461 pre 431 29 post
Test: PASSED
Status: 17 pre 19 post
Test: PASSED
Test: PASSED
Status: 413 pre 397 15 post
Test: PASSED
Status: 19 pre 21 post
Test: PASSED
Test: PASSED
Status: 404 pre 341 62 post
Test: PASSED
Status: 21 pre 23 post
Test: PASSED
Test: PASSED
Status: 464 pre 451 12 post
Test: PASSED
Status: 23 pre 25 post
Test: PASSED
Test: PASSED
Status: 440 pre 258 181 post
Test: PASSED
Status: 25 pre 27 post
Test: PASSED
Test: PASSED
Status: 441 pre 200 240 post
Test: PASSED
Status: 27 pre 29 post
Test: PASSED
Test: PASSED
Status: 363 pre 138 224 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 259 pre 85 173 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 457 pre 456 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 313 pre 81 231 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 367 pre 221 145 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 415 pre 414 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 455 pre 185 269 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 494 pre 484 9 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 486 pre 478 7 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 381 pre 344 36 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 494 pre 464 29 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 269 pre 93 175 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 424 pre 415 8 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 476 pre 330 145 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 447 pre 440 6 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 401 pre 169 231 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 400 pre 258 141 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 214 pre 166 47 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 440 pre 424 15 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 373 pre 50 322 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 279 pre 82 196 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 348 pre 231 116 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 456 pre 228 227 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 417 pre 416 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 494 pre 425 68 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 283 pre 71 211 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 233 pre 153 79 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 387 pre 275 111 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 458 pre 430 27 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 450 pre 440 9 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 384 pre 93 290 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 38 pre 26 11 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 479 pre 81 397 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 487 pre 424 62 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 346 pre 243 102 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 468 pre 404 63 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 376 pre 106 269 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 332 pre 8 323 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 378 pre 235 142 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 69 pre 13 55 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 68 pre 67 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 337 pre 165 171 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 385 pre 251 133 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 484 pre 287 196 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 325 pre 270 54 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 485 pre 473 11 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 476 pre 422 53 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 457 pre 192 264 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 202 pre 56 145 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 372 pre 274 97 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 315 pre 307 7 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 383 pre 382 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 437 pre 419 17 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 225 pre 108 116 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 322 pre 138 183 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 138 pre 118 19 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 387 pre 157 229 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 44 448 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 468 pre 81 386 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 462 pre 163 298 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 325 pre 235 89 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 262 pre 83 178 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 311 pre 198 112 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 211 pre 210 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 215 pre 126 88 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 333 pre 47 285 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 335 pre 263 71 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 462 pre 418 43 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 207 pre 150 56 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 498 pre 170 327 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 478 pre 326 151 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 393 pre 349 43 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 488 pre 487 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 414 pre 413 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 411 pre 227 183 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 306 pre 21 284 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 211 pre 201 9 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 293 pre 210 82 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 281 pre 276 4 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 248 pre 60 187 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 381 pre 254 126 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 493 pre 492 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 420 pre 214 205 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 439 pre 438 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 405 pre 63 341 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 447 pre 378 68 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 406 pre 160 245 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 294 pre 204 89 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 389 pre 314 74 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 250 pre 249 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 402 pre 380 21 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 477 pre 357 119 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 474 pre 426 47 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 423 pre 277 145 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 336 pre 330 5 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 302 pre 208 93 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 409 pre 331 77 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 372 pre 118 253 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 174 pre 116 57 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 473 pre 470 2 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 283 pre 174 108 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 485 pre 484 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 418 pre 33 384 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 485 pre 481 3 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 308 pre 94 213 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 470 pre 248 221 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 458 pre 453 4 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 455 pre 454 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 480 pre 473 6 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 485 pre 480 4 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 272 pre 209 62 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 481 pre 480 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 263 pre 189 73 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 495 pre 460 34 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 448 pre 431 16 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 277 pre 255 21 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 242 pre 235 6 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 392 pre 387 4 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 464 pre 150 313 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 260 pre 50 209 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 403 pre 311 91 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 458 pre 395 62 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 308 pre 30 277 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 429 pre 84 344 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 432 pre 431 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 422 pre 398 23 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 318 pre 129 188 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 318 pre 211 106 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 415 pre 371 43 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 458 pre 408 49 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 427 pre 298 128 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 481 pre 325 155 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 278 pre 218 59 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 401 pre 189 211 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 233 pre 18 214 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 493 pre 491 1 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 466 pre 417 48 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 40 pre 18 21 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 489 3 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 370 pre 221 148 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 480 pre 428 51 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 136 pre 102 33 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 465 pre 380 84 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 115 pre 18 96 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 430 pre 426 3 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 477 pre 425 51 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 472 20 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 219 pre 105 113 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 497 pre 495 1 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 497 pre 426 70 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 342 pre 290 51 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 492 pre 483 8 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 214 pre 181 32 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 492 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 498 pre 325 172 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 44 pre 4 39 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 468 pre 456 11 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 400 pre 321 78 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 357 pre 13 343 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 433 pre 413 19 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 167 pre 147 19 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 440 pre 220 219 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 251 pre 195 55 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 396 pre 276 119 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 448 pre 213 234 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 495 pre 487 7 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 378 pre 10 367 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 431 pre 103 327 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 475 pre 434 40 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 479 pre 464 14 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 422 pre 334 87 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 463 pre 462 0 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 376 pre 370 5 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 469 pre 383 85 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 216 pre 215 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 361 pre 308 52 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 232 pre 185 46 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 482 pre 46 435 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 487 pre 227 259 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 36 pre 8 27 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 426 pre 420 5 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 414 pre 393 20 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 460 pre 230 229 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 183 pre 100 82 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 250 pre 6 243 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 275 pre 274 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 449 pre 51 397 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 272 pre 156 115 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 394 pre 272 121 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 397 pre 68 328 post
Test: PASSED
Status: 13 pre 15 post
Test: PASSED
Test: PASSED
Status: 385 pre 280 104 post
Test: PASSED
Status: 15 pre 17 post
Test: PASSED
Test: PASSED
Status: 224 pre 76 147 post
Test: PASSED
Status: 17 pre 19 post
Test: PASSED
Test: PASSED
Status: 478 pre 471 6 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 496 pre 495 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 344 pre 343 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 405 pre 233 171 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 477 pre 475 1 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 495 pre 494 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 379 pre 339 39 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 408 pre 367 40 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 390 pre 389 0 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 498 pre 410 87 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 403 pre 363 39 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 348 pre 217 130 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 368 pre 353 14 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 417 pre 99 317 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 496 pre 495 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 188 pre 87 100 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 301 pre 29 271 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 480 pre 439 40 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 454 pre 296 157 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 494 pre 493 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 486 pre 280 205 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 275 pre 274 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 475 pre 440 34 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 331 pre 330 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 419 pre 369 49 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 300 pre 219 80 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 478 pre 463 14 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 171 pre 160 10 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 302 pre 217 84 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 317 pre 289 27 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 479 pre 401 77 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 395 pre 102 292 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 492 pre 468 23 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 374 pre 355 18 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 388 pre 106 281 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 435 pre 376 58 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 495 pre 471 23 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 359 pre 239 119 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 305 pre 29 275 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 437 pre 436 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 358 pre 181 176 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 408 pre 260 147 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 276 pre 25 250 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 369 pre 59 309 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 139 pre 63 75 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 422 pre 134 287 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 355 pre 292 62 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 489 pre 486 2 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 368 pre 107 260 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 464 pre 116 347 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 140 pre 12 127 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 464 pre 384 79 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 493 pre 428 64 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 373 pre 333 39 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 453 pre 366 86 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 256 pre 176 79 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 498 pre 445 52 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 425 pre 424 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 496 pre 391 104 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 491 pre 455 35 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 241 pre 209 31 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 471 pre 303 167 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 159 pre 98 60 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 292 pre 290 1 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 365 pre 246 118 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 487 pre 356 130 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 417 pre 416 0 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 451 pre 450 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 257 pre 18 238 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 498 pre 64 433 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 260 pre 215 44 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 492 pre 378 113 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 284 pre 190 93 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 456 pre 382 73 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 438 pre 247 190 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 393 pre 249 143 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 234 pre 157 76 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 447 pre 412 34 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 426 pre 374 51 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 463 pre 167 295 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 169 pre 104 64 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 386 pre 111 274 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 494 pre 491 2 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 425 pre 420 4 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 422 pre 391 30 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 399 pre 113 285 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 220 pre 219 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 485 pre 448 36 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 113 pre 108 4 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 151 pre 29 121 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 441 pre 255 185 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 414 pre 138 275 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 410 pre 365 44 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 475 pre 380 94 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 304 pre 54 249 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 488 pre 487 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 424 pre 338 85 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 77 pre 43 33 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 351 pre 269 81 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 373 pre 314 58 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 378 pre 295 82 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 474 pre 458 15 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 486 pre 478 7 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 381 pre 232 148 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 436 pre 395 40 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 434 pre 297 136 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 485 pre 269 215 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 245 pre 213 31 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 271 pre 248 22 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 479 pre 404 74 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 493 pre 457 35 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 483 pre 322 160 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 381 pre 372 8 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 492 pre 489 2 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 476 pre 341 134 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 249 pre 243 5 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 177 pre 145 31 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 323 pre 234 88 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 399 pre 214 184 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 384 pre 117 266 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 382 pre 288 93 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 438 pre 119 318 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 481 pre 109 371 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 334 pre 224 109 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 342 pre 168 173 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 283 pre 281 1 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 217 pre 214 2 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 437 pre 436 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 265 pre 196 68 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 337 pre 325 11 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 70 pre 24 45 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 274 pre 210 63 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 365 pre 257 107 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 251 pre 142 108 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 483 pre 143 339 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 259 pre 205 53 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 431 pre 311 119 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 339 pre 257 81 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 266 pre 265 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 480 pre 448 31 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 360 pre 200 159 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 293 pre 105 187 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 378 pre 352 25 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 423 pre 24 398 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 431 pre 190 240 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 486 pre 467 18 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 488 pre 397 90 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 399 pre 169 229 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 492 pre 462 29 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 446 pre 445 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 402 pre 274 127 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 309 pre 233 75 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 432 pre 306 125 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 467 pre 373 93 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 221 pre 6 214 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 413 pre 334 78 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 197 pre 182 14 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 409 pre 382 26 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 228 pre 134 93 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 368 pre 291 76 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 383 pre 270 112 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 484 pre 483 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 408 pre 71 336 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 493 pre 492 0 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 436 pre 435 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 483 pre 469 13 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 308 pre 122 185 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 467 pre 449 17 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 379 pre 278 100 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 192 pre 107 84 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 467 pre 462 4 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 479 pre 465 13 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 303 pre 162 140 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 139 pre 78 60 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 450 pre 240 209 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 452 pre 411 40 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 362 pre 326 35 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 399 pre 87 311 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 293 pre 192 100 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 322 pre 70 251 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 377 pre 369 7 post
Test: PASSED
Status: 5 pre 7 post
Test: PASSED
Test: PASSED
Status: 468 pre 464 3 post
Test: PASSED
Status: 7 pre 9 post
Test: PASSED
Test: PASSED
Status: 481 pre 274 206 post
Test: PASSED
Status: 9 pre 11 post
Test: PASSED
Test: PASSED
Status: 189 pre 149 39 post
Test: PASSED
Status: 11 pre 13 post
Test: PASSED
Test: PASSED
Status: 432 pre 431 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 290 pre 233 56 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 221 pre 220 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 444 pre 356 87 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 88 pre 75 12 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 494 pre 493 0 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 498 pre 261 236 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 272 pre 136 135 post
Test: PASSED
Status: 3 pre 5 post
Test: PASSED
Test: PASSED
Status: 467 pre 305 161 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Test: PASSED
Status: 273 pre 166 106 post
Test: PASSED
Status: 1 pre 3 post
Test: PASSED
Status: 0 failures of the playVillage
File 'randomtestcard2.c'
Lines executed:95.74% of 47
Creating 'randomtestcard2.c.gcov'

File 'dominion.c'
Lines executed:24.11% of 564
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
  1043010:    8:int compare(const void* a, const void* b) {
  1043010:    9:  if (*(int*)a > *(int*)b)
   515776:   10:    return 1;
   527234:   11:  if (*(int*)a < *(int*)b)
   232340:   12:    return -1;
   294894:   13:  return 0;
        -:   14:}
        -:   15:
      500:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
      500:   18:      drawCard(currentPlayer, state);
        -:   19:			
        -:   20:      //+2 Actions
      500:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
      500:   24:      discardCard(handPos, currentPlayer, state, 0);
      500:   25:}
        -:   26:
    #####:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
    #####:   29:    for (i = 1; i < 3; i++)
        -:   30:	{
    #####:   31:	  drawCard(currentPlayer, state);
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
    #####:   36:      discardCard(handPos, currentPlayer, state, 0);
        -:   37: 
        -:   38:
    #####:   39:}
    #####:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
    #####:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
    #####:   44:int z = 0;
    #####:   45:while(drawntreasure<2){
    #####:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
    #####:   47:	  shuffle(currentPlayer, state);
        -:   48:	}
    #####:   49:	drawCard(currentPlayer, state);
        -:   50:
    #####:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   52:	if (cardDrawn == copper || cardDrawn == silver)
    #####:   53:	  drawntreasure++;
        -:   54:	else{
    #####:   55:	  temphand[z]=cardDrawn;
    #####:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   57:	  z++;
        -:   58:	}
        -:   59:      }
    #####:   60:      while(z-1>=0){
    #####:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   62:	z=z-1;
    #####:   63:      }}
        -:   64:
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
    #####:   91:		isGameOver(state);
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
    #####:  108:	    isGameOver(state);
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
    #####:  121:	  drawCard(currentPlayer, state);
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
    #####:  139:}
        -:  140:
        -:  141:
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
      500:  171:  PutSeed((long)randomSeed);
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:  175:    {
      261:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      239:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2629:  183:  for (i = 0; i < 10; i++)
        -:  184:    {
    26290:  185:      for (j = 0; j < 10; j++)
        -:  186:        {
    23900:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      239:  199:  if (numPlayers == 2)
        -:  200:    {
      123:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      116:  203:  else if (numPlayers == 3)
        -:  204:    {
      116:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      239:  213:  if (numPlayers == 2)
        -:  214:    {
      123:  215:      state->supplyCount[estate] = 8;
      123:  216:      state->supplyCount[duchy] = 8;
      123:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      116:  221:      state->supplyCount[estate] = 12;
      116:  222:      state->supplyCount[duchy] = 12;
      116:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      239:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      239:  228:  state->supplyCount[silver] = 40;
      239:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5019:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  233:    {
    39435:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  235:	{
    37045:  236:	  if (kingdomCards[j] == i)
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2390:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  240:		{
      478:  241:		  if (numPlayers == 2){ 
      123:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      116:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2151:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2390:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    34655:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      833:  264:  for (i = 0; i < numPlayers; i++)
        -:  265:    {
      594:  266:      state->deckCount[i] = 0;
     2376:  267:      for (j = 0; j < 3; j++)
        -:  268:	{
     1782:  269:	  state->deck[i][j] = estate;
     1782:  270:	  state->deckCount[i]++;
        -:  271:	}
     4752:  272:      for (j = 3; j < 10; j++)
        -:  273:	{
     4158:  274:	  state->deck[i][j] = copper;
     4158:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      833:  280:  for (i = 0; i < numPlayers; i++)
        -:  281:    {
      594:  282:      if ( shuffle(i, state) < 0 )
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      833:  289:  for (i = 0; i < numPlayers; i++)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      594:  292:      state->handCount[i] = 0;
      594:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6692:  302:  for (i = 0; i <= treasure_map; i++)
        -:  303:    {
     6453:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      239:  308:  state->outpostPlayed = 0;
      239:  309:  state->phase = 0;
      239:  310:  state->numActions = 1;
      239:  311:  state->numBuys = 1;
      239:  312:  state->playedCardCount = 0;
      239:  313:  state->whoseTurn = 0;
      239:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1434:  318:  for (it = 0; it < 5; it++){
     1195:  319:    drawCard(state->whoseTurn, state);
        -:  320:  }
        -:  321:
      239:  322:  updateCoins(state->whoseTurn, state, 0);
        -:  323:
      239:  324:  return 0;
        -:  325:}
        -:  326:
     1141:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1141:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1141:  335:  if (state->deckCount[player] < 1)
    #####:  336:    return -1;
     1141:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   155335:  340:  while (state->deckCount[player] > 0) {
   153053:  341:    card = floor(Random() * state->deckCount[player]);
   153053:  342:    newDeck[newDeckPos] = state->deck[player][card];
   153053:  343:    newDeckPos++;
 12968734:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
 12815681:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   153053:  347:    state->deckCount[player]--;
        -:  348:  }
   154194:  349:  for (i = 0; i < newDeckPos; i++) {
   153053:  350:    state->deck[player][i] = newDeck[i];
   153053:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1141:  354:  return 0;
        -:  355:}
        -:  356:
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
        -:  439:}
        -:  440:
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
     1695:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
     1695:  654:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    19004:  659:    for (i = 0; i < state->discardCount[player];i++){
    18957:  660:      state->deck[player][i] = state->discard[player][i];
    18957:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       47:  664:    state->deckCount[player] = state->discardCount[player];
       47:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       47:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       47:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       47:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       47:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       47:  685:    if (deckCounter == 0)
    #####:  686:      return -1;
        -:  687:
       47:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       47:  689:    state->deckCount[player]--;
       47:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
     1648:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
     1648:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
     1648:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1648:  702:    state->deckCount[player]--;
     1648:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
     1695:  706:  return 0;
        -:  707:}
        -:  708:
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
    #####:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
        -:  794:    {
        -:  795:    case adventurer:
    #####:  796:      playAdventurer(currentPlayer, state, handPos);
    #####:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
    #####:  836:	if (supplyCount(choice1, state) <= 0){
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
    #####:  845:	  printf("That card is too expensive!\n");
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
    #####:  943:      playSmithy(currentPlayer, state, handPos);
    #####:  944:      return 0;
        -:  945:
        -:  946:    case village:
      500:  947:      playVillage(currentPlayer, state, handPos);
      500:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1070:	  drawCard(currentPlayer, state);
    #####: 1071:	  drawCard(currentPlayer, state);
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
    #####: 1216:	if (i != currentPlayer){
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
      500: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
      500: 1262:  if (trashFlag < 1)
        -: 1263:    {
        -: 1264:      //add card to played pile
      500: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      500: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
      500: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
      500: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
      500: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
      500: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
      500: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
      500: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
      500: 1293:  return 0;
        -: 1294:}
        -: 1295:
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
      239: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      239: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1434: 1341:  for (i = 0; i < state->handCount[player]; i++)
        -: 1342:    {
     1195: 1343:      if (state->hand[player][i] == copper)
        -: 1344:	{
      825: 1345:	  state->coins += 1;
        -: 1346:	}
      370: 1347:      else if (state->hand[player][i] == silver)
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      370: 1351:      else if (state->hand[player][i] == gold)
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      239: 1358:  state->coins += bonus;
        -: 1359:
      239: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
File 'randomtestcard2.c'
Lines executed:95.74% of 47
Branches executed:100.00% of 16
Taken at least once:93.75% of 16
Calls executed:95.65% of 23
Creating 'randomtestcard2.c.gcov'

File 'dominion.c'
Lines executed:24.11% of 564
Branches executed:24.34% of 415
Taken at least once:16.39% of 415
Calls executed:12.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 1043010 returned 100% blocks executed 100%
  1043010:    8:int compare(const void* a, const void* b) {
  1043010:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 515776 (fallthrough)
branch  1 taken 527234
   515776:   10:    return 1;
   527234:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 232340 (fallthrough)
branch  1 taken 294894
   232340:   12:    return -1;
   294894:   13:  return 0;
        -:   14:}
        -:   15:
function playVillage called 500 returned 100% blocks executed 100%
      500:   16:void playVillage(int currentPlayer, struct gameState* state, int handPos){
        -:   17:    //+1 Card
      500:   18:      drawCard(currentPlayer, state);
call    0 returned 500
        -:   19:			
        -:   20:      //+2 Actions
      500:   21:      state->numActions = state->numActions + 2;
        -:   22:			
        -:   23:      //discard played card from hand
      500:   24:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 500
      500:   25:}
        -:   26:
function playSmithy called 0 returned 0% blocks executed 0%
    #####:   27:void playSmithy(int currentPlayer, struct gameState* state, int handPos){
        -:   28:    int i;
    #####:   29:    for (i = 1; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:   30:	{
    #####:   31:	  drawCard(currentPlayer, state);
call    0 never executed
        -:   32:	}
        -:   33:
        -:   34:			
        -:   35:      //discard card from hand
    #####:   36:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:   37: 
        -:   38:
    #####:   39:}
function playAdventurer called 0 returned 0% blocks executed 0%
    #####:   40:void playAdventurer(int currentPlayer, struct gameState* state, int handPos){
    #####:   41:int drawntreasure = 0;
        -:   42:int cardDrawn;
        -:   43:int temphand[MAX_HAND];
    #####:   44:int z = 0;
    #####:   45:while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:   46:	if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:   47:	  shuffle(currentPlayer, state);
call    0 never executed
        -:   48:	}
    #####:   49:	drawCard(currentPlayer, state);
call    0 never executed
        -:   50:
    #####:   51:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:   52:	if (cardDrawn == copper || cardDrawn == silver)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   53:	  drawntreasure++;
        -:   54:	else{
    #####:   55:	  temphand[z]=cardDrawn;
    #####:   56:	  state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:   57:	  z++;
        -:   58:	}
        -:   59:      }
    #####:   60:      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:   61:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:   62:	z=z-1;
    #####:   63:      }}
        -:   64:
function playBaron called 0 returned 0% blocks executed 0%
    #####:   65:void playBaron( int currentPlayer, struct gameState* state, int handPos, int choice1) {
    #####:   66: state->numBuys++;//Increase buys by 1!
    #####:   67:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:   68:	int p = 1;//Iterator for hand!
    #####:   69:	int card_not_discarded = 1;//Flag for discard set!
    #####:   70:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:   71:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:   72:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:   73:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:   74:	    state->discardCount[currentPlayer]++;
    #####:   75:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:   76:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   77:	    }
    #####:   78:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:   79:	    state->handCount[currentPlayer]--;
    #####:   80:	    card_not_discarded = 0;//Exit the loop
        -:   81:	  }
    #####:   82:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:   83:	    if(DEBUG) {
        -:   84:	      printf("No estate cards in your hand, invalid choice\n");
        -:   85:	      printf("Must gain an estate if there are any\n");
        -:   86:	    }
    #####:   87:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   88:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:   89:	      state->supplyCount[estate]--;//Decrement estates
    #####:   90:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   91:		isGameOver(state);
call    0 never executed
        -:   92:	      }
        -:   93:	    }
    #####:   94:	    card_not_discarded = 0;//Exit the loop
        -:   95:	  }
        -:   96:			    
        -:   97:	  else{
    #####:   98:	    p++;//Next card
        -:   99:	  }
        -:  100:	}
        -:  101:      }
        -:  102:			    
        -:  103:      else{
    #####:  104:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  105:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  106:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  107:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:	    isGameOver(state);
call    0 never executed
        -:  109:	  }
        -:  110:	}
        -:  111:      }
        -:  112:	    
        -:  113:
    #####:  114:}
        -:  115:
function playSteward called 0 returned 0% blocks executed 0%
    #####:  116:void playSteward(int currentPlayer, struct gameState* state, int handPos, int choice1, int choice2, int choice3){
    #####:  117:   if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  118:	{
        -:  119:	  //+2 cards
    #####:  120:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  121:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  122:	}
    #####:  123:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  124:	{
        -:  125:	  //+2 coins
    #####:  126:	  state->coins = state->coins + 2;
        -:  127:	}
        -:  128:      else
        -:  129:	{
        -:  130:	  
    #####:  131:    state->coins = state->coins + 2;
        -:  132:    //trash 2 cards in hand
    #####:  133:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  134:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  135:	}
        -:  136:			
        -:  137:      //discard card from hand
    #####:  138:      discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####:  139:}
        -:  140:
        -:  141:
function newGame called 0 returned 0% blocks executed 0%
    #####:  142:struct gameState* newGame() {
    #####:  143:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:  144:  return g;
        -:  145:}
        -:  146:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:  147:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  148:		  int k8, int k9, int k10) {
    #####:  149:  int* k = malloc(10 * sizeof(int));
    #####:  150:  k[0] = k1;
    #####:  151:  k[1] = k2;
    #####:  152:  k[2] = k3;
    #####:  153:  k[3] = k4;
    #####:  154:  k[4] = k5;
    #####:  155:  k[5] = k6;
    #####:  156:  k[6] = k7;
    #####:  157:  k[7] = k8;
    #####:  158:  k[8] = k9;
    #####:  159:  k[9] = k10;
    #####:  160:  return k;
        -:  161:}
        -:  162:
function initializeGame called 500 returned 100% blocks executed 95%
      500:  163:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  164:		   struct gameState *state) {
        -:  165:
        -:  166:  int i;
        -:  167:  int j;
        -:  168:  int it;			
        -:  169:  //set up random number generator
      500:  170:  SelectStream(1);
call    0 returned 500
      500:  171:  PutSeed((long)randomSeed);
call    0 returned 500
        -:  172:  
        -:  173:  //check number of players
      500:  174:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 500 (fallthrough)
branch  1 taken 0
branch  2 taken 261 (fallthrough)
branch  3 taken 239
        -:  175:    {
      261:  176:      return -1;
        -:  177:    }
        -:  178:
        -:  179:  //set number of players
      239:  180:  state->numPlayers = numPlayers;
        -:  181:
        -:  182:  //check selected kingdom cards are different
     2629:  183:  for (i = 0; i < 10; i++)
branch  0 taken 2390
branch  1 taken 239 (fallthrough)
        -:  184:    {
    26290:  185:      for (j = 0; j < 10; j++)
branch  0 taken 23900
branch  1 taken 2390 (fallthrough)
        -:  186:        {
    23900:  187:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 21510 (fallthrough)
branch  1 taken 2390
branch  2 taken 0 (fallthrough)
branch  3 taken 21510
        -:  188:	    {
    #####:  189:	      return -1;
        -:  190:	    }
        -:  191:        }
        -:  192:    }
        -:  193:
        -:  194:
        -:  195:  //initialize supply
        -:  196:  ///////////////////////////////
        -:  197:
        -:  198:  //set number of Curse cards
      239:  199:  if (numPlayers == 2)
branch  0 taken 123 (fallthrough)
branch  1 taken 116
        -:  200:    {
      123:  201:      state->supplyCount[curse] = 10;
        -:  202:    }
      116:  203:  else if (numPlayers == 3)
branch  0 taken 116 (fallthrough)
branch  1 taken 0
        -:  204:    {
      116:  205:      state->supplyCount[curse] = 20;
        -:  206:    }
        -:  207:  else
        -:  208:    {
    #####:  209:      state->supplyCount[curse] = 30;
        -:  210:    }
        -:  211:
        -:  212:  //set number of Victory cards
      239:  213:  if (numPlayers == 2)
branch  0 taken 123 (fallthrough)
branch  1 taken 116
        -:  214:    {
      123:  215:      state->supplyCount[estate] = 8;
      123:  216:      state->supplyCount[duchy] = 8;
      123:  217:      state->supplyCount[province] = 8;
        -:  218:    }
        -:  219:  else
        -:  220:    {
      116:  221:      state->supplyCount[estate] = 12;
      116:  222:      state->supplyCount[duchy] = 12;
      116:  223:      state->supplyCount[province] = 12;
        -:  224:    }
        -:  225:
        -:  226:  //set number of Treasure cards
      239:  227:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      239:  228:  state->supplyCount[silver] = 40;
      239:  229:  state->supplyCount[gold] = 30;
        -:  230:
        -:  231:  //set number of Kingdom cards
     5019:  232:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 4780
branch  1 taken 239 (fallthrough)
        -:  233:    {
    39435:  234:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 37045
branch  1 taken 2390 (fallthrough)
        -:  235:	{
    37045:  236:	  if (kingdomCards[j] == i)
branch  0 taken 2390 (fallthrough)
branch  1 taken 34655
        -:  237:	    {
        -:  238:	      //check if card is a 'Victory' Kingdom card
     2390:  239:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 2151 (fallthrough)
branch  1 taken 239
branch  2 taken 0 (fallthrough)
branch  3 taken 2151
        -:  240:		{
      478:  241:		  if (numPlayers == 2){ 
branch  0 taken 123 (fallthrough)
branch  1 taken 116
      123:  242:		    state->supplyCount[i] = 8; 
        -:  243:		  }
      116:  244:		  else{ state->supplyCount[i] = 12; }
        -:  245:		}
        -:  246:	      else
        -:  247:		{
     2151:  248:		  state->supplyCount[i] = 10;
        -:  249:		}
     2390:  250:	      break;
        -:  251:	    }
        -:  252:	  else    //card is not in the set choosen for the game
        -:  253:	    {
    34655:  254:	      state->supplyCount[i] = -1;
        -:  255:	    }
        -:  256:	}
        -:  257:
        -:  258:    }
        -:  259:
        -:  260:  ////////////////////////
        -:  261:  //supply intilization complete
        -:  262:
        -:  263:  //set player decks
      833:  264:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  265:    {
      594:  266:      state->deckCount[i] = 0;
     2376:  267:      for (j = 0; j < 3; j++)
branch  0 taken 1782
branch  1 taken 594 (fallthrough)
        -:  268:	{
     1782:  269:	  state->deck[i][j] = estate;
     1782:  270:	  state->deckCount[i]++;
        -:  271:	}
     4752:  272:      for (j = 3; j < 10; j++)
branch  0 taken 4158
branch  1 taken 594 (fallthrough)
        -:  273:	{
     4158:  274:	  state->deck[i][j] = copper;
     4158:  275:	  state->deckCount[i]++;		
        -:  276:	}
        -:  277:    }
        -:  278:
        -:  279:  //shuffle player decks
      833:  280:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  281:    {
      594:  282:      if ( shuffle(i, state) < 0 )
call    0 returned 594
branch  1 taken 0 (fallthrough)
branch  2 taken 594
        -:  283:	{
    #####:  284:	  return -1;
        -:  285:	}
        -:  286:    }
        -:  287:
        -:  288:  //draw player hands
      833:  289:  for (i = 0; i < numPlayers; i++)
branch  0 taken 594
branch  1 taken 239 (fallthrough)
        -:  290:    {  
        -:  291:      //initialize hand size to zero
      594:  292:      state->handCount[i] = 0;
      594:  293:      state->discardCount[i] = 0;
        -:  294:      //draw 5 cards
        -:  295:      // for (j = 0; j < 5; j++)
        -:  296:      //	{
        -:  297:      //	  drawCard(i, state);
        -:  298:      //	}
        -:  299:    }
        -:  300:  
        -:  301:  //set embargo tokens to 0 for all supply piles
     6692:  302:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 6453
branch  1 taken 239 (fallthrough)
        -:  303:    {
     6453:  304:      state->embargoTokens[i] = 0;
        -:  305:    }
        -:  306:
        -:  307:  //initialize first player's turn
      239:  308:  state->outpostPlayed = 0;
      239:  309:  state->phase = 0;
      239:  310:  state->numActions = 1;
      239:  311:  state->numBuys = 1;
      239:  312:  state->playedCardCount = 0;
      239:  313:  state->whoseTurn = 0;
      239:  314:  state->handCount[state->whoseTurn] = 0;
        -:  315:  //int it; move to top
        -:  316:
        -:  317:  //Moved draw cards to here, only drawing at the start of a turn
     1434:  318:  for (it = 0; it < 5; it++){
branch  0 taken 1195
branch  1 taken 239 (fallthrough)
     1195:  319:    drawCard(state->whoseTurn, state);
call    0 returned 1195
        -:  320:  }
        -:  321:
      239:  322:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 239
        -:  323:
      239:  324:  return 0;
        -:  325:}
        -:  326:
function shuffle called 1141 returned 100% blocks executed 94%
     1141:  327:int shuffle(int player, struct gameState *state) {
        -:  328: 
        -:  329:
        -:  330:  int newDeck[MAX_DECK];
     1141:  331:  int newDeckPos = 0;
        -:  332:  int card;
        -:  333:  int i;
        -:  334:
     1141:  335:  if (state->deckCount[player] < 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 1141
    #####:  336:    return -1;
     1141:  337:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 1141
        -:  338:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  339:
   155335:  340:  while (state->deckCount[player] > 0) {
branch  0 taken 153053
branch  1 taken 1141 (fallthrough)
   153053:  341:    card = floor(Random() * state->deckCount[player]);
call    0 returned 153053
   153053:  342:    newDeck[newDeckPos] = state->deck[player][card];
   153053:  343:    newDeckPos++;
 12968734:  344:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 12815681
branch  1 taken 153053 (fallthrough)
 12815681:  345:      state->deck[player][i] = state->deck[player][i+1];
        -:  346:    }
   153053:  347:    state->deckCount[player]--;
        -:  348:  }
   154194:  349:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 153053
branch  1 taken 1141 (fallthrough)
   153053:  350:    state->deck[player][i] = newDeck[i];
   153053:  351:    state->deckCount[player]++;
        -:  352:  }
        -:  353:
     1141:  354:  return 0;
        -:  355:}
        -:  356:
function playCard called 0 returned 0% blocks executed 0%
    #####:  357:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  358:{	
        -:  359:  int card;
    #####:  360:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  361:
        -:  362:  //check if it is the right phase
    #####:  363:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  364:    {
    #####:  365:      return -1;
        -:  366:    }
        -:  367:	
        -:  368:  //check if player has enough actions
    #####:  369:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  370:    {
    #####:  371:      return -1;
        -:  372:    }
        -:  373:	
        -:  374:  //get card played
    #####:  375:  card = handCard(handPos, state);
call    0 never executed
        -:  376:	
        -:  377:  //check if selected card is an action
    #####:  378:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  379:    {
    #####:  380:      return -1;
        -:  381:    }
        -:  382:	
        -:  383:  //play card
    #####:  384:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  385:    {
    #####:  386:      return -1;
        -:  387:    }
        -:  388:	
        -:  389:  //reduce number of actions
    #####:  390:  state->numActions--;
        -:  391:
        -:  392:  //update coins (Treasure cards may be added with card draws)
    #####:  393:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  394:	
    #####:  395:  return 0;
        -:  396:}
        -:  397:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  398:int buyCard(int supplyPos, struct gameState *state) {
        -:  399:  int who;
        -:  400:  if (DEBUG){
        -:  401:    printf("Entering buyCard...\n");
        -:  402:  }
        -:  403:
        -:  404:  // I don't know what to do about the phase thing.
        -:  405:
    #####:  406:  who = state->whoseTurn;
        -:  407:
    #####:  408:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  409:    if (DEBUG)
        -:  410:      printf("You do not have any buys left\n");
    #####:  411:    return -1;
    #####:  412:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  413:    if (DEBUG)
        -:  414:      printf("There are not any of that type of card left\n");
    #####:  415:    return -1;
    #####:  416:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  417:    if (DEBUG) 
        -:  418:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  419:    return -1;
        -:  420:  } else {
    #####:  421:    state->phase=1;
        -:  422:    //state->supplyCount[supplyPos]--;
    #####:  423:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  424:  
    #####:  425:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  426:    state->numBuys--;
        -:  427:    if (DEBUG)
        -:  428:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  429:  }
        -:  430:
        -:  431:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  432:  //state->discardCount[who]++;
        -:  433:    
    #####:  434:  return 0;
        -:  435:}
        -:  436:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  437:int numHandCards(struct gameState *state) {
    #####:  438:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  439:}
        -:  440:
function handCard called 0 returned 0% blocks executed 0%
    #####:  441:int handCard(int handPos, struct gameState *state) {
    #####:  442:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  443:  return state->hand[currentPlayer][handPos];
        -:  444:}
        -:  445:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  446:int supplyCount(int card, struct gameState *state) {
    #####:  447:  return state->supplyCount[card];
        -:  448:}
        -:  449:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  450:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  451:  int i;
    #####:  452:  int count = 0;
        -:  453:
    #####:  454:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  455:    {
    #####:  456:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  457:    }
        -:  458:
    #####:  459:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  460:    {
    #####:  461:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  462:    }
        -:  463:
    #####:  464:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
    #####:  466:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  467:    }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
function whoseTurn called 500 returned 100% blocks executed 100%
      500:  472:int whoseTurn(struct gameState *state) {
      500:  473:  return state->whoseTurn;
        -:  474:}
        -:  475:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  476:int endTurn(struct gameState *state) {
        -:  477:  int k;
        -:  478:  int i;
    #####:  479:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  480:  
        -:  481:  //Discard hand
    #####:  482:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  483:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  484:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  485:  }
    #####:  486:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  487:    
        -:  488:  //Code for determining the player
    #####:  489:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  490:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  491:  }
        -:  492:  else{
    #####:  493:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  494:  }
        -:  495:
    #####:  496:  state->outpostPlayed = 0;
    #####:  497:  state->phase = 0;
    #####:  498:  state->numActions = 1;
    #####:  499:  state->coins = 0;
    #####:  500:  state->numBuys = 1;
    #####:  501:  state->playedCardCount = 0;
    #####:  502:  state->handCount[state->whoseTurn] = 0;
        -:  503:
        -:  504:  //int k; move to top
        -:  505:  //Next player draws hand
    #####:  506:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  507:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  508:  }
        -:  509:
        -:  510:  //Update money
    #####:  511:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  512:
    #####:  513:  return 0;
        -:  514:}
        -:  515:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  516:int isGameOver(struct gameState *state) {
        -:  517:  int i;
        -:  518:  int j;
        -:  519:	
        -:  520:  //if stack of Province cards is empty, the game ends
    #####:  521:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  522:    {
    #####:  523:      return 1;
        -:  524:    }
        -:  525:
        -:  526:  //if three supply pile are at 0, the game ends
    #####:  527:  j = 0;
    #####:  528:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  529:    {
    #####:  530:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  531:	{
    #####:  532:	  j++;
        -:  533:	}
        -:  534:    }
    #####:  535:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  536:    {
    #####:  537:      return 1;
        -:  538:    }
        -:  539:
    #####:  540:  return 0;
        -:  541:}
        -:  542:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  543:int scoreFor (int player, struct gameState *state) {
        -:  544:
        -:  545:  int i;
    #####:  546:  int score = 0;
        -:  547:  //score from hand
    #####:  548:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  549:    {
    #####:  550:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  551:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  552:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  553:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  554:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  555:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  556:    }
        -:  557:
        -:  558:  //score from discard
    #####:  559:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  560:    {
    #####:  561:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  562:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  563:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  564:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  565:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  566:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  567:    }
        -:  568:
        -:  569:  //score from deck
    #####:  570:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  571:    {
    #####:  572:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  573:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  574:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  575:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  576:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  577:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  578:    }
        -:  579:
    #####:  580:  return score;
        -:  581:}
        -:  582:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  583:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  584:  int i;	
        -:  585:  int j;
        -:  586:  int highScore;
        -:  587:  int currentPlayer;
        -:  588:
        -:  589:  //get score for each player
    #####:  590:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  591:    {
        -:  592:      //set unused player scores to -9999
    #####:  593:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  594:	{
    #####:  595:	  players[i] = -9999;
        -:  596:	}
        -:  597:      else
        -:  598:	{
    #####:  599:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  600:	}
        -:  601:    }
        -:  602:
        -:  603:  //find highest score
    #####:  604:  j = 0;
    #####:  605:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  606:    {
    #####:  607:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  608:	{
    #####:  609:	  j = i;
        -:  610:	}
        -:  611:    }
    #####:  612:  highScore = players[j];
        -:  613:
        -:  614:  //add 1 to players who had less turns
    #####:  615:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  616:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  617:    {
    #####:  618:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  619:	{
    #####:  620:	  players[i]++;
        -:  621:	}
        -:  622:    }
        -:  623:
        -:  624:  //find new highest score
    #####:  625:  j = 0;
    #####:  626:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  627:    {
    #####:  628:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  629:	{
    #####:  630:	  j = i;
        -:  631:	}
        -:  632:    }
    #####:  633:  highScore = players[j];
        -:  634:
        -:  635:  //set winners in array to 1 and rest to 0
    #####:  636:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  637:    {
    #####:  638:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  639:	{
    #####:  640:	  players[i] = 1;
        -:  641:	}
        -:  642:      else
        -:  643:	{
    #####:  644:	  players[i] = 0;
        -:  645:	}
        -:  646:    }
        -:  647:
    #####:  648:  return 0;
        -:  649:}
        -:  650:
function drawCard called 1695 returned 100% blocks executed 92%
     1695:  651:int drawCard(int player, struct gameState *state)
        -:  652:{	int count;
        -:  653:  int deckCounter;
     1695:  654:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 47 (fallthrough)
branch  1 taken 1648
        -:  655:    
        -:  656:    //Step 1 Shuffle the discard pile back into a deck
        -:  657:    int i;
        -:  658:    //Move discard to deck
    19004:  659:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 18957
branch  1 taken 47 (fallthrough)
    18957:  660:      state->deck[player][i] = state->discard[player][i];
    18957:  661:      state->discard[player][i] = -1;
        -:  662:    }
        -:  663:
       47:  664:    state->deckCount[player] = state->discardCount[player];
       47:  665:    state->discardCount[player] = 0;//Reset discard
        -:  666:
        -:  667:    //Shufffle the deck
       47:  668:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 47
        -:  669:   
        -:  670:    if (DEBUG){//Debug statements
        -:  671:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  672:    }
        -:  673:    
       47:  674:    state->discardCount[player] = 0;
        -:  675:
        -:  676:    //Step 2 Draw Card
       47:  677:    count = state->handCount[player];//Get current player's hand count
        -:  678:    
        -:  679:    if (DEBUG){//Debug statements
        -:  680:      printf("Current hand count: %d\n", count);
        -:  681:    }
        -:  682:    
       47:  683:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  684:
       47:  685:    if (deckCounter == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 47
    #####:  686:      return -1;
        -:  687:
       47:  688:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       47:  689:    state->deckCount[player]--;
       47:  690:    state->handCount[player]++;//Increment hand count
        -:  691:  }
        -:  692:
        -:  693:  else{
     1648:  694:    int count = state->handCount[player];//Get current hand count for player
        -:  695:    int deckCounter;
        -:  696:    if (DEBUG){//Debug statements
        -:  697:      printf("Current hand count: %d\n", count);
        -:  698:    }
        -:  699:
     1648:  700:    deckCounter = state->deckCount[player];//Create holder for the deck count
     1648:  701:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1648:  702:    state->deckCount[player]--;
     1648:  703:    state->handCount[player]++;//Increment hand count
        -:  704:  }
        -:  705:
     1695:  706:  return 0;
        -:  707:}
        -:  708:
function getCost called 0 returned 0% blocks executed 0%
    #####:  709:int getCost(int cardNumber)
        -:  710:{
    #####:  711:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  712:    {
        -:  713:    case curse:
    #####:  714:      return 0;
        -:  715:    case estate:
    #####:  716:      return 2;
        -:  717:    case duchy:
    #####:  718:      return 5;
        -:  719:    case province:
    #####:  720:      return 8;
        -:  721:    case copper:
    #####:  722:      return 0;
        -:  723:    case silver:
    #####:  724:      return 3;
        -:  725:    case gold:
    #####:  726:      return 6;
        -:  727:    case adventurer:
    #####:  728:      return 6;
        -:  729:    case council_room:
    #####:  730:      return 5;
        -:  731:    case feast:
    #####:  732:      return 4;
        -:  733:    case gardens:
    #####:  734:      return 4;
        -:  735:    case mine:
    #####:  736:      return 5;
        -:  737:    case remodel:
    #####:  738:      return 4;
        -:  739:    case smithy:
    #####:  740:      return 4;
        -:  741:    case village:
    #####:  742:      return 3;
        -:  743:    case baron:
    #####:  744:      return 4;
        -:  745:    case great_hall:
    #####:  746:      return 3;
        -:  747:    case minion:
    #####:  748:      return 5;
        -:  749:    case steward:
    #####:  750:      return 3;
        -:  751:    case tribute:
    #####:  752:      return 5;
        -:  753:    case ambassador:
    #####:  754:      return 3;
        -:  755:    case cutpurse:
    #####:  756:      return 4;
        -:  757:    case embargo: 
    #####:  758:      return 2;
        -:  759:    case outpost:
    #####:  760:      return 5;
        -:  761:    case salvager:
    #####:  762:      return 4;
        -:  763:    case sea_hag:
    #####:  764:      return 4;
        -:  765:    case treasure_map:
    #####:  766:      return 4;
        -:  767:    }
        -:  768:	
    #####:  769:  return -1;
        -:  770:}
        -:  771:
function cardEffect called 500 returned 100% blocks executed 3%
      500:  772:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  773:{
        -:  774:  int i;
        -:  775:  int j;
        -:  776:  int k;
        -:  777:  int x;
        -:  778:  int index;
      500:  779:  int currentPlayer = whoseTurn(state);
call    0 returned 500
      500:  780:  int nextPlayer = currentPlayer + 1;
        -:  781:
      500:  782:  int tributeRevealedCards[2] = {-1, -1};
        -:  783:  int temphand[MAX_HAND];// moved above the if statement
        -:  784:  
        -:  785:  
        -:  786:  
      500:  787:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    #####:  788:    nextPlayer = 0;
        -:  789:  }
        -:  790:  
        -:  791:	
        -:  792:  //uses switch to select card and perform actions
      500:  793:  switch( card ) 
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 500
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 0
branch 12 taken 0
branch 13 taken 0
branch 14 taken 0
branch 15 taken 0
branch 16 taken 0
branch 17 taken 0
branch 18 taken 0
branch 19 taken 0
branch 20 taken 0
        -:  794:    {
        -:  795:    case adventurer:
    #####:  796:      playAdventurer(currentPlayer, state, handPos);
call    0 never executed
    #####:  797:      return 0;
        -:  798:			
        -:  799:    case council_room:
        -:  800:      //+4 Cards
    #####:  801:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  802:	{
    #####:  803:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  804:	}
        -:  805:			
        -:  806:      //+1 Buy
    #####:  807:      state->numBuys++;
        -:  808:			
        -:  809:      //Each other player draws a card
    #####:  810:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  811:	{
    #####:  812:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  813:	    {
    #####:  814:	      drawCard(i, state);
call    0 never executed
        -:  815:	    }
        -:  816:	}
        -:  817:			
        -:  818:      //put played card in played card pile
    #####:  819:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  820:			
    #####:  821:      return 0;
        -:  822:			
        -:  823:    case feast:
        -:  824:      //gain card with cost up to 5
        -:  825:      //Backup hand
    #####:  826:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  827:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  828:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  829:      }
        -:  830:      //Backup hand
        -:  831:
        -:  832:      //Update Coins for Buy
    #####:  833:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  834:      x = 1;//Condition to loop on
    #####:  835:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  836:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  837:	  if (DEBUG)
        -:  838:	    printf("None of that card left, sorry!\n");
        -:  839:
        -:  840:	  if (DEBUG){
        -:  841:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  842:	  }
        -:  843:	}
    #####:  844:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  846:
        -:  847:	  if (DEBUG){
        -:  848:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  849:	  }
        -:  850:	}
        -:  851:	else{
        -:  852:
        -:  853:	  if (DEBUG){
        -:  854:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  855:	  }
        -:  856:
    #####:  857:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  858:	  x = 0;//No more buying cards
        -:  859:
        -:  860:	  if (DEBUG){
        -:  861:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  862:	  }
        -:  863:
        -:  864:	}
        -:  865:      }     
        -:  866:
        -:  867:      //Reset Hand
    #####:  868:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  869:	state->hand[currentPlayer][i] = temphand[i];
    #####:  870:	temphand[i] = -1;
        -:  871:      }
        -:  872:      //Reset Hand
        -:  873:      			
    #####:  874:      return 0;
        -:  875:			
        -:  876:    case gardens:
        -:  877:      
    #####:  878:      return -1;
        -:  879:			
        -:  880:    case mine:
    #####:  881:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  882:
    #####:  883:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  884:	{
    #####:  885:	  return -1;
        -:  886:	}
        -:  887:		
    #####:  888:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  894:	{
    #####:  895:	  return -1;
        -:  896:	}
        -:  897:
    #####:  898:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  899:
        -:  900:      //discard card from hand
    #####:  901:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  902:
        -:  903:      //discard trashed card
    #####:  904:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  905:	{
    #####:  906:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  907:	    {
    #####:  908:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  909:	      break;
        -:  910:	    }
        -:  911:	}
        -:  912:			
    #####:  913:      return 0;
        -:  914:			
        -:  915:    case remodel:
    #####:  916:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  917:
    #####:  918:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  919:	{
    #####:  920:	  return -1;
        -:  921:	}
        -:  922:
    #####:  923:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  924:
        -:  925:      //discard card from hand
    #####:  926:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  927:
        -:  928:      //discard trashed card
    #####:  929:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  930:	{
    #####:  931:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  932:	    {
    #####:  933:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  934:	      break;
        -:  935:	    }
        -:  936:	}
        -:  937:
        -:  938:
    #####:  939:      return 0;
        -:  940:		
        -:  941:    case smithy:
        -:  942:      //+3 Cards
    #####:  943:      playSmithy(currentPlayer, state, handPos);
call    0 never executed
    #####:  944:      return 0;
        -:  945:
        -:  946:    case village:
      500:  947:      playVillage(currentPlayer, state, handPos);
call    0 returned 500
      500:  948:      return 0;
        -:  949:		
        -:  950:    case baron:
    #####:  951:     playBaron(currentPlayer, state, handPos, choice1);
call    0 never executed
        -:  952:      
    #####:  953:      return 0;
        -:  954:		
        -:  955:    case great_hall:
        -:  956:      //+1 Card
    #####:  957:      drawCard(currentPlayer, state);
call    0 never executed
        -:  958:			
        -:  959:      //+1 Actions
    #####:  960:      state->numActions++;
        -:  961:			
        -:  962:      //discard card from hand
    #####:  963:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case minion:
        -:  967:      //+1 action
    #####:  968:      state->numActions++;
        -:  969:			
        -:  970:      //discard card from hand
    #####:  971:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  972:			
    #####:  973:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  974:	{
    #####:  975:	  state->coins = state->coins + 2;
        -:  976:	}
        -:  977:			
    #####:  978:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  979:	{
        -:  980:	  //discard hand
    #####:  981:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  982:	    {
    #####:  983:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  984:	    }
        -:  985:				
        -:  986:	  //draw 4
    #####:  987:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  988:	    {
    #####:  989:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  990:	    }
        -:  991:				
        -:  992:	  //other players discard hand and redraw if hand size > 4
    #####:  993:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  994:	    {
    #####:  995:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  996:		{
    #####:  997:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  998:		    {
        -:  999:		      //discard hand
    #####: 1000:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1001:			{
    #####: 1002:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1003:			}
        -: 1004:							
        -: 1005:		      //draw 4
    #####: 1006:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1007:			{
    #####: 1008:			  drawCard(i, state);
call    0 never executed
        -: 1009:			}
        -: 1010:		    }
        -: 1011:		}
        -: 1012:	    }
        -: 1013:				
        -: 1014:	}
    #####: 1015:      return 0;
        -: 1016:		
        -: 1017:    case steward:
    #####: 1018:     playSteward(currentPlayer, state, handPos, choice1, choice2, choice3);
call    0 never executed
    #####: 1019:      return 0;
        -: 1020:		
        -: 1021:    case tribute:
    #####: 1022:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1023:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1024:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1025:	  state->deckCount[nextPlayer]--;
        -: 1026:	}
    #####: 1027:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1028:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1029:	  state->discardCount[nextPlayer]--;
        -: 1030:	}
        -: 1031:	else{
        -: 1032:	  //No Card to Reveal
        -: 1033:	  if (DEBUG){
        -: 1034:	    printf("No cards to reveal\n");
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:	    
        -: 1039:      else{
    #####: 1040:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1041:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1042:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1043:	    state->deckCount[nextPlayer]++;
    #####: 1044:	    state->discard[nextPlayer][i] = -1;
    #####: 1045:	    state->discardCount[nextPlayer]--;
        -: 1046:	  }
        -: 1047:			    
    #####: 1048:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1049:	} 
    #####: 1050:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1051:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1052:	state->deckCount[nextPlayer]--;
    #####: 1053:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1054:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1055:	state->deckCount[nextPlayer]--;
        -: 1056:      }    
        -: 1057:		       
    #####: 1058:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1059:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1060:	state->playedCardCount++;
    #####: 1061:	tributeRevealedCards[1] = -1;
        -: 1062:      }
        -: 1063:
    #####: 1064:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1065:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1066:	  state->coins += 2;
        -: 1067:	}
        -: 1068:		    
    #####: 1069:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1070:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1071:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1072:	}
        -: 1073:	else{//Action Card
    #####: 1074:	  state->numActions = state->numActions + 2;
        -: 1075:	}
        -: 1076:      }
        -: 1077:	    
    #####: 1078:      return 0;
        -: 1079:		
        -: 1080:    case ambassador:
    #####: 1081:      j = 0;		//used to check if player has enough cards to discard
        -: 1082:
    #####: 1083:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1084:	{
    #####: 1085:	  return -1;				
        -: 1086:	}
        -: 1087:
    #####: 1088:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1089:	{
    #####: 1090:	  return -1;
        -: 1091:	}
        -: 1092:
    #####: 1093:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1094:	{
    #####: 1095:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1096:	    {
    #####: 1097:	      j++;
        -: 1098:	    }
        -: 1099:	}
    #####: 1100:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1101:	{
    #####: 1102:	  return -1;				
        -: 1103:	}
        -: 1104:
        -: 1105:      if (DEBUG) 
        -: 1106:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1107:
        -: 1108:      //increase supply count for choosen card by amount being discarded
    #####: 1109:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1110:			
        -: 1111:      //each other player gains a copy of revealed card
    #####: 1112:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1113:	{
    #####: 1114:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1115:	    {
    #####: 1116:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1117:	    }
        -: 1118:	}
        -: 1119:
        -: 1120:      //discard played card from hand
    #####: 1121:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1122:
        -: 1123:      //trash copies of cards returned to supply
    #####: 1124:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1127:	    {
    #####: 1128:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1129:		{
    #####: 1130:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1131:		  break;
        -: 1132:		}
        -: 1133:	    }
        -: 1134:	}			
        -: 1135:
    #####: 1136:      return 0;
        -: 1137:		
        -: 1138:    case cutpurse:
        -: 1139:
    #####: 1140:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1141:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1142:	{
    #####: 1143:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1144:	    {
    #####: 1145:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1146:		{
    #####: 1147:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1148:		    {
    #####: 1149:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1150:		      break;
        -: 1151:		    }
    #####: 1152:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1153:		    {
    #####: 1154:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1155:			{
        -: 1156:			  if (DEBUG)
        -: 1157:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1158:			}	
    #####: 1159:		      break;
        -: 1160:		    }		
        -: 1161:		}
        -: 1162:					
        -: 1163:	    }
        -: 1164:				
        -: 1165:	}				
        -: 1166:
        -: 1167:      //discard played card from hand
    #####: 1168:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1169:
    #####: 1170:      return 0;
        -: 1171:
        -: 1172:		
        -: 1173:    case embargo: 
        -: 1174:      //+2 Coins
    #####: 1175:      state->coins = state->coins + 2;
        -: 1176:			
        -: 1177:      //see if selected pile is in play
    #####: 1178:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1179:	{
    #####: 1180:	  return -1;
        -: 1181:	}
        -: 1182:			
        -: 1183:      //add embargo token to selected supply pile
    #####: 1184:      state->embargoTokens[choice1]++;
        -: 1185:			
        -: 1186:      //trash card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case outpost:
        -: 1191:      //set outpost flag
    #####: 1192:      state->outpostPlayed++;
        -: 1193:			
        -: 1194:      //discard card
    #####: 1195:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1196:      return 0;
        -: 1197:		
        -: 1198:    case salvager:
        -: 1199:      //+1 buy
    #####: 1200:      state->numBuys++;
        -: 1201:			
    #####: 1202:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1203:	{
        -: 1204:	  //gain coins equal to trashed card
    #####: 1205:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1206:	  //trash card
    #####: 1207:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1208:	}
        -: 1209:			
        -: 1210:      //discard card
    #####: 1211:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1212:      return 0;
        -: 1213:		
        -: 1214:    case sea_hag:
    #####: 1215:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1216:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1217:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1218:	  state->discardCount[i]++;
    #####: 1219:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1220:	}
        -: 1221:      }
    #####: 1222:      return 0;
        -: 1223:		
        -: 1224:    case treasure_map:
        -: 1225:      //search hand for another treasure_map
    #####: 1226:      index = -1;
    #####: 1227:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1228:	{
    #####: 1229:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1230:	    {
    #####: 1231:	      index = i;
    #####: 1232:	      break;
        -: 1233:	    }
        -: 1234:	}
    #####: 1235:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1236:	{
        -: 1237:	  //trash both treasure cards
    #####: 1238:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1239:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1240:
        -: 1241:	  //gain 4 Gold cards
    #####: 1242:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1243:	    {
    #####: 1244:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1245:	    }
        -: 1246:				
        -: 1247:	  //return success
    #####: 1248:	  return 1;
        -: 1249:	}
        -: 1250:			
        -: 1251:      //no second treasure_map found in hand
    #####: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
    #####: 1255:  return -1;
        -: 1256:}
        -: 1257:
function discardCard called 500 returned 100% blocks executed 78%
      500: 1258:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1259:{
        -: 1260:	
        -: 1261:  //if card is not trashed, added to Played pile 
      500: 1262:  if (trashFlag < 1)
branch  0 taken 500 (fallthrough)
branch  1 taken 0
        -: 1263:    {
        -: 1264:      //add card to played pile
      500: 1265:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      500: 1266:      state->playedCardCount++;
        -: 1267:    }
        -: 1268:	
        -: 1269:  //set played card to -1
      500: 1270:  state->hand[currentPlayer][handPos] = -1;
        -: 1271:	
        -: 1272:  //remove card from player's hand
      500: 1273:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0 (fallthrough)
branch  1 taken 500
        -: 1274:    {
        -: 1275:      //reduce number of cards in hand
    #####: 1276:      state->handCount[currentPlayer]--;
        -: 1277:    }
      500: 1278:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0 (fallthrough)
branch  1 taken 500
        -: 1279:    {
        -: 1280:      //reduce number of cards in hand
    #####: 1281:      state->handCount[currentPlayer]--;
        -: 1282:    }
        -: 1283:  else 	
        -: 1284:    {
        -: 1285:      //replace discarded card with last card in hand
      500: 1286:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1287:      //set last card to -1
      500: 1288:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1289:      //reduce number of cards in hand
      500: 1290:      state->handCount[currentPlayer]--;
        -: 1291:    }
        -: 1292:	
      500: 1293:  return 0;
        -: 1294:}
        -: 1295:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1296:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1297:{
        -: 1298:  //Note: supplyPos is enum of choosen card
        -: 1299:	
        -: 1300:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1301:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1302:    {
    #####: 1303:      return -1;
        -: 1304:    }
        -: 1305:	
        -: 1306:  //added card for [whoseTurn] current player:
        -: 1307:  // toFlag = 0 : add to discard
        -: 1308:  // toFlag = 1 : add to deck
        -: 1309:  // toFlag = 2 : add to hand
        -: 1310:
    #####: 1311:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1312:    {
    #####: 1313:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1314:      state->deckCount[player]++;
        -: 1315:    }
    #####: 1316:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1317:    {
    #####: 1318:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1319:      state->handCount[player]++;
        -: 1320:    }
        -: 1321:  else
        -: 1322:    {
    #####: 1323:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1324:      state->discardCount[player]++;
        -: 1325:    }
        -: 1326:	
        -: 1327:  //decrease number in supply pile
    #####: 1328:  state->supplyCount[supplyPos]--;
        -: 1329:	 
    #####: 1330:  return 0;
        -: 1331:}
        -: 1332:
function updateCoins called 239 returned 100% blocks executed 82%
      239: 1333:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1334:{
        -: 1335:  int i;
        -: 1336:	
        -: 1337:  //reset coin count
      239: 1338:  state->coins = 0;
        -: 1339:
        -: 1340:  //add coins for each Treasure card in player's hand
     1434: 1341:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 1195
branch  1 taken 239 (fallthrough)
        -: 1342:    {
     1195: 1343:      if (state->hand[player][i] == copper)
branch  0 taken 825 (fallthrough)
branch  1 taken 370
        -: 1344:	{
      825: 1345:	  state->coins += 1;
        -: 1346:	}
      370: 1347:      else if (state->hand[player][i] == silver)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -: 1348:	{
    #####: 1349:	  state->coins += 2;
        -: 1350:	}
      370: 1351:      else if (state->hand[player][i] == gold)
branch  0 taken 0 (fallthrough)
branch  1 taken 370
        -: 1352:	{
    #####: 1353:	  state->coins += 3;
        -: 1354:	}	
        -: 1355:    }	
        -: 1356:
        -: 1357:  //add bonus
      239: 1358:  state->coins += bonus;
        -: 1359:
      239: 1360:  return 0;
        -: 1361:}
        -: 1362:
        -: 1363:
        -: 1364://end of dominion.c
